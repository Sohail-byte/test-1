{
  "resolvedId": "C:/Users/XFXRe/Desktop/Portfolio/node_modules/vite-plugin-inspect/dist/index.mjs",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import process from 'node:process';\nimport sirv from 'sirv';\nimport c from 'picocolors';\nimport { debounce } from 'perfect-debounce';\nimport { dirname, resolve, isAbsolute, join } from 'node:path';\nimport { fileURLToPath } from 'node:url';\nimport { Buffer as Buffer$1 } from 'node:buffer';\nimport { createFilter } from '@rollup/pluginutils';\nimport Debug from 'debug';\nimport { parse } from 'error-stack-parser-es';\nimport fs from 'fs-extra';\nimport { createServer } from 'node:http';\n\nconst DEFAULT_TIMEOUT = 6e4;\nfunction defaultSerialize(i) {\n  return i;\n}\nconst defaultDeserialize = defaultSerialize;\nconst { clearTimeout, setTimeout: setTimeout$1 } = globalThis;\nconst random = Math.random.bind(Math);\nfunction createBirpc(functions, options) {\n  const {\n    post,\n    on,\n    eventNames = [],\n    serialize = defaultSerialize,\n    deserialize = defaultDeserialize,\n    resolver,\n    timeout = DEFAULT_TIMEOUT\n  } = options;\n  const rpcPromiseMap = /* @__PURE__ */ new Map();\n  let _promise;\n  const rpc = new Proxy({}, {\n    get(_, method) {\n      if (method === \"$functions\")\n        return functions;\n      const sendEvent = (...args) => {\n        post(serialize({ m: method, a: args, t: \"q\" }));\n      };\n      if (eventNames.includes(method)) {\n        sendEvent.asEvent = sendEvent;\n        return sendEvent;\n      }\n      const sendCall = async (...args) => {\n        await _promise;\n        return new Promise((resolve, reject) => {\n          const id = nanoid();\n          let timeoutId;\n          if (timeout >= 0) {\n            timeoutId = setTimeout$1(() => {\n              reject(new Error(`[birpc] timeout on calling \"${method}\"`));\n              rpcPromiseMap.delete(id);\n            }, timeout).unref?.();\n          }\n          rpcPromiseMap.set(id, { resolve, reject, timeoutId });\n          post(serialize({ m: method, a: args, i: id, t: \"q\" }));\n        });\n      };\n      sendCall.asEvent = sendEvent;\n      return sendCall;\n    }\n  });\n  _promise = on(async (data, ...extra) => {\n    const msg = deserialize(data);\n    if (msg.t === \"q\") {\n      const { m: method, a: args } = msg;\n      let result, error;\n      const fn = resolver ? resolver(method, functions[method]) : functions[method];\n      if (!fn) {\n        error = new Error(`[birpc] function \"${method}\" not found`);\n      } else {\n        try {\n          result = await fn.apply(rpc, args);\n        } catch (e) {\n          error = e;\n        }\n      }\n      if (msg.i) {\n        if (error && options.onError)\n          options.onError(error, method, args);\n        post(serialize({ t: \"s\", i: msg.i, r: result, e: error }), ...extra);\n      }\n    } else {\n      const { i: ack, r: result, e: error } = msg;\n      const promise = rpcPromiseMap.get(ack);\n      if (promise) {\n        clearTimeout(promise.timeoutId);\n        if (error)\n          promise.reject(error);\n        else\n          promise.resolve(result);\n      }\n      rpcPromiseMap.delete(ack);\n    }\n  });\n  return rpc;\n}\nconst cacheMap = /* @__PURE__ */ new WeakMap();\nfunction cachedMap(items, fn) {\n  return items.map((i) => {\n    let r = cacheMap.get(i);\n    if (!r) {\n      r = fn(i);\n      cacheMap.set(i, r);\n    }\n    return r;\n  });\n}\nfunction createBirpcGroup(functions, channels, options = {}) {\n  const getChannels = () => typeof channels === \"function\" ? channels() : channels;\n  const getClients = (channels2 = getChannels()) => cachedMap(channels2, (s) => createBirpc(functions, { ...options, ...s }));\n  const broadcastProxy = new Proxy({}, {\n    get(_, method) {\n      const client = getClients();\n      const callbacks = client.map((c) => c[method]);\n      const sendCall = (...args) => {\n        return Promise.all(callbacks.map((i) => i(...args)));\n      };\n      sendCall.asEvent = (...args) => {\n        callbacks.map((i) => i.asEvent(...args));\n      };\n      return sendCall;\n    }\n  });\n  function updateChannels(fn) {\n    const channels2 = getChannels();\n    fn?.(channels2);\n    return getClients(channels2);\n  }\n  getClients();\n  return {\n    get clients() {\n      return getClients();\n    },\n    functions,\n    updateChannels,\n    broadcast: broadcastProxy,\n    /**\n     * @deprecated use `broadcast`\n     */\n    // @ts-expect-error deprecated\n    boardcast: broadcastProxy\n  };\n}\nconst urlAlphabet = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nfunction nanoid(size = 21) {\n  let id = \"\";\n  let i = size;\n  while (i--)\n    id += urlAlphabet[random() * 64 | 0];\n  return id;\n}\n\nfunction createRPCServer(name, ws, functions, options = {}) {\n  const event = `${name}:rpc`;\n  const group = createBirpcGroup(\n    functions,\n    () => cachedMap(\n      Array.from(ws?.clients || []),\n      (socket) => {\n        return {\n          on: (fn) => {\n            ws.on(event, (data, source) => {\n              if (socket === source)\n                fn(data);\n            });\n          },\n          post: (data) => {\n            socket.send(event, data);\n          }\n        };\n      }\n    ),\n    options\n  );\n  ws.on(\"connection\", () => {\n    group.updateChannels();\n  });\n  return group.broadcast;\n}\n\nconst DIR_DIST = typeof __dirname !== \"undefined\" ? __dirname : dirname(fileURLToPath(import.meta.url));\nconst DIR_CLIENT = resolve(DIR_DIST, \"../dist/client\");\n\nconst DUMMY_LOAD_PLUGIN_NAME = \"__load__\";\n\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => {\n  __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass Recorder {\n  constructor() {\n    __publicField$1(this, \"transform\", {});\n    __publicField$1(this, \"resolveId\", {});\n    __publicField$1(this, \"transformCounter\", {});\n  }\n  recordTransform(id, info, preTransformCode) {\n    if (!this.transform[id] || !this.transform[id].some((tr) => tr.result)) {\n      this.transform[id] = [{\n        name: DUMMY_LOAD_PLUGIN_NAME,\n        result: preTransformCode,\n        start: info.start,\n        end: info.start,\n        sourcemaps: info.sourcemaps\n      }];\n      this.transformCounter[id] = (this.transformCounter[id] || 0) + 1;\n    }\n    this.transform[id].push(info);\n  }\n  recordLoad(id, info) {\n    this.transform[id] = [info];\n    this.transformCounter[id] = (this.transformCounter[id] || 0) + 1;\n  }\n  recordResolveId(id, info) {\n    if (!this.resolveId[id])\n      this.resolveId[id] = [];\n    this.resolveId[id].push(info);\n  }\n  invalidate(id) {\n    delete this.transform[id];\n  }\n}\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass ViteInspectContext {\n  constructor(options) {\n    this.options = options;\n    __publicField(this, \"filter\");\n    __publicField(this, \"config\");\n    __publicField(this, \"recorderClient\", new Recorder());\n    __publicField(this, \"recorderServer\", new Recorder());\n    this.filter = createFilter(options.include, options.exclude);\n  }\n  getRecorder(ssr) {\n    return ssr ? this.recorderServer : this.recorderClient;\n  }\n  resolveId(id = \"\", ssr = false) {\n    if (id.startsWith(\"./\"))\n      id = resolve(this.config.root, id).replace(/\\\\/g, \"/\");\n    return this.resolveIdRecursive(id, ssr);\n  }\n  resolveIdRecursive(id, ssr = false) {\n    const rec = this.getRecorder(ssr);\n    const resolved = rec.resolveId[id]?.[0]?.result;\n    return resolved ? this.resolveIdRecursive(resolved, ssr) : id;\n  }\n  getList(server) {\n    const isVirtual = (pluginName) => pluginName !== DUMMY_LOAD_PLUGIN_NAME;\n    const getDeps = (id) => Array.from(server.moduleGraph.getModuleById(id)?.importedModules || []).map((i) => i.id || \"\").filter(Boolean);\n    return {\n      root: this.config.root,\n      modules: this.getModulesInfo(this.recorderClient, getDeps, isVirtual),\n      ssrModules: this.getModulesInfo(this.recorderServer, getDeps, isVirtual)\n    };\n  }\n  getModulesInfo(recorder, getDeps, isVirtual) {\n    function transformIdMap(recorder2) {\n      return Object.values(recorder2.resolveId).reduce((map, ids2) => {\n        ids2.forEach((id) => {\n          var _a;\n          map[_a = id.result] ?? (map[_a] = []);\n          map[id.result].push(id);\n        });\n        return map;\n      }, {});\n    }\n    const transformedIdMap = transformIdMap(recorder);\n    const ids = new Set(Object.keys(recorder.transform).concat(Object.keys(transformedIdMap)));\n    return Array.from(ids).sort().map((id) => {\n      let totalTime = 0;\n      const plugins = (recorder.transform[id] || []).filter((tr) => tr.result).map((transItem) => {\n        const delta = transItem.end - transItem.start;\n        totalTime += delta;\n        return { name: transItem.name, transform: delta };\n      }).concat(\n        // @ts-expect-error transform is optional\n        (transformedIdMap[id] || []).map((idItem) => {\n          return { name: idItem.name, resolveId: idItem.end - idItem.start };\n        })\n      );\n      function getSize(str) {\n        if (!str)\n          return 0;\n        return Buffer$1.byteLength(str, \"utf8\");\n      }\n      return {\n        id,\n        deps: getDeps ? getDeps(id) : [],\n        plugins,\n        virtual: isVirtual(plugins[0]?.name || \"\", recorder.transform[id]?.[0].name || \"\"),\n        totalTime,\n        invokeCount: recorder.transformCounter?.[id] || 0,\n        sourceSize: getSize(recorder.transform[id]?.[0]?.result),\n        distSize: getSize(recorder.transform[id]?.[recorder.transform[id].length - 1]?.result)\n      };\n    });\n  }\n  getPluginMetrics(ssr = false) {\n    const map = {};\n    const defaultMetricInfo = () => ({\n      transform: { invokeCount: 0, totalTime: 0 },\n      resolveId: { invokeCount: 0, totalTime: 0 }\n    });\n    this.config.plugins.forEach((i) => {\n      map[i.name] = {\n        ...defaultMetricInfo(),\n        name: i.name,\n        enforce: i.enforce\n      };\n    });\n    const recorder = this.getRecorder(ssr);\n    Object.values(recorder.transform).forEach((transformInfos) => {\n      transformInfos.forEach(({ name, start, end }) => {\n        if (name === DUMMY_LOAD_PLUGIN_NAME)\n          return;\n        if (!map[name])\n          map[name] = { ...defaultMetricInfo(), name };\n        map[name].transform.totalTime += end - start;\n        map[name].transform.invokeCount += 1;\n      });\n    });\n    Object.values(recorder.resolveId).forEach((resolveIdInfos) => {\n      resolveIdInfos.forEach(({ name, start, end }) => {\n        if (!map[name])\n          map[name] = { ...defaultMetricInfo(), name };\n        map[name].resolveId.totalTime += end - start;\n        map[name].resolveId.invokeCount += 1;\n      });\n    });\n    const metrics = Object.values(map).filter(Boolean).sort((a, b) => a.name.localeCompare(b.name));\n    return metrics;\n  }\n}\n\nconst debug = Debug(\"vite-plugin-inspect\");\nfunction hijackHook(plugin, name, wrapper) {\n  if (!plugin[name])\n    return;\n  debug(`hijack plugin \"${name}\"`, plugin.name);\n  let order = plugin.order || plugin.enforce || \"normal\";\n  const hook = plugin[name];\n  if (\"handler\" in hook) {\n    const oldFn = hook.handler;\n    order += `-${hook.order || hook.enforce || \"normal\"}`;\n    hook.handler = function(...args) {\n      return wrapper(oldFn, this, args, order);\n    };\n  } else if (\"transform\" in hook) {\n    const oldFn = hook.transform;\n    order += `-${hook.order || hook.enforce || \"normal\"}`;\n    hook.transform = function(...args) {\n      return wrapper(oldFn, this, args, order);\n    };\n  } else {\n    const oldFn = hook;\n    plugin[name] = function(...args) {\n      return wrapper(oldFn, this, args, order);\n    };\n  }\n}\nfunction hijackPlugin(plugin, ctx) {\n  hijackHook(plugin, \"transform\", async (fn, context, args, order) => {\n    const code = args[0];\n    const id = args[1];\n    const ssr = args[2]?.ssr;\n    let _result;\n    let error;\n    const start = Date.now();\n    try {\n      _result = await fn.apply(context, args);\n    } catch (_err) {\n      error = _err;\n    }\n    const end = Date.now();\n    const result = error ? \"[Error]\" : typeof _result === \"string\" ? _result : _result?.code;\n    if (ctx.filter(id)) {\n      const sourcemaps = typeof _result === \"string\" ? null : _result?.map;\n      const rec = ctx.getRecorder(ssr);\n      rec.recordTransform(id, {\n        name: plugin.name,\n        result,\n        start,\n        end,\n        order,\n        sourcemaps,\n        error: error ? parseError(error) : void 0\n      }, code);\n    }\n    if (error)\n      throw error;\n    return _result;\n  });\n  hijackHook(plugin, \"load\", async (fn, context, args) => {\n    const id = args[0];\n    const ssr = args[1]?.ssr;\n    let _result;\n    let error;\n    const start = Date.now();\n    try {\n      _result = await fn.apply(context, args);\n    } catch (err) {\n      error = err;\n    }\n    const end = Date.now();\n    const result = error ? \"[Error]\" : typeof _result === \"string\" ? _result : _result?.code;\n    const sourcemaps = typeof _result === \"string\" ? null : _result?.map;\n    if (result) {\n      ctx.getRecorder(ssr).recordLoad(id, {\n        name: plugin.name,\n        result,\n        start,\n        end,\n        sourcemaps,\n        error: error ? parseError(error) : void 0\n      });\n    }\n    if (error)\n      throw error;\n    return _result;\n  });\n  hijackHook(plugin, \"resolveId\", async (fn, context, args) => {\n    const id = args[0];\n    const ssr = args[2]?.ssr;\n    let _result;\n    let error;\n    const start = Date.now();\n    try {\n      _result = await fn.apply(context, args);\n    } catch (err) {\n      error = err;\n    }\n    const end = Date.now();\n    if (!ctx.filter(id)) {\n      if (error)\n        throw error;\n      return _result;\n    }\n    const result = error ? stringifyError(error) : typeof _result === \"object\" ? _result?.id : _result;\n    if (result && result !== id) {\n      ctx.getRecorder(ssr).recordResolveId(id, {\n        name: plugin.name,\n        result,\n        start,\n        end,\n        error\n      });\n    }\n    if (error)\n      throw error;\n    return _result;\n  });\n}\nfunction parseError(error) {\n  const stack = parse(error);\n  const message = error.message || String(error);\n  return {\n    message,\n    stack,\n    raw: error\n  };\n}\nfunction stringifyError(err) {\n  return String(err.stack ? err.stack : err);\n}\n\nconst defaults = Object.freeze({\n  ignoreUnknown: false,\n  respectType: false,\n  respectFunctionNames: false,\n  respectFunctionProperties: false,\n  unorderedObjects: true,\n  unorderedArrays: false,\n  unorderedSets: false,\n  excludeKeys: void 0,\n  excludeValues: void 0,\n  replacer: void 0\n});\nfunction objectHash(object, options) {\n  if (options) {\n    options = { ...defaults, ...options };\n  } else {\n    options = defaults;\n  }\n  const hasher = createHasher(options);\n  hasher.dispatch(object);\n  return hasher.toString();\n}\nconst defaultPrototypesKeys = Object.freeze([\n  \"prototype\",\n  \"__proto__\",\n  \"constructor\"\n]);\nfunction createHasher(options) {\n  let buff = \"\";\n  let context = /* @__PURE__ */ new Map();\n  const write = (str) => {\n    buff += str;\n  };\n  return {\n    toString() {\n      return buff;\n    },\n    getContext() {\n      return context;\n    },\n    dispatch(value) {\n      if (options.replacer) {\n        value = options.replacer(value);\n      }\n      const type = value === null ? \"null\" : typeof value;\n      return this[type](value);\n    },\n    object(object) {\n      if (object && typeof object.toJSON === \"function\") {\n        return this.object(object.toJSON());\n      }\n      const objString = Object.prototype.toString.call(object);\n      let objType = \"\";\n      const objectLength = objString.length;\n      if (objectLength < 10) {\n        objType = \"unknown:[\" + objString + \"]\";\n      } else {\n        objType = objString.slice(8, objectLength - 1);\n      }\n      objType = objType.toLowerCase();\n      let objectNumber = null;\n      if ((objectNumber = context.get(object)) === void 0) {\n        context.set(object, context.size);\n      } else {\n        return this.dispatch(\"[CIRCULAR:\" + objectNumber + \"]\");\n      }\n      if (typeof Buffer !== \"undefined\" && Buffer.isBuffer && Buffer.isBuffer(object)) {\n        write(\"buffer:\");\n        return write(object.toString(\"utf8\"));\n      }\n      if (objType !== \"object\" && objType !== \"function\" && objType !== \"asyncfunction\") {\n        if (this[objType]) {\n          this[objType](object);\n        } else if (!options.ignoreUnknown) {\n          this.unkown(object, objType);\n        }\n      } else {\n        let keys = Object.keys(object);\n        if (options.unorderedObjects) {\n          keys = keys.sort();\n        }\n        let extraKeys = [];\n        if (options.respectType !== false && !isNativeFunction(object)) {\n          extraKeys = defaultPrototypesKeys;\n        }\n        if (options.excludeKeys) {\n          keys = keys.filter((key) => {\n            return !options.excludeKeys(key);\n          });\n          extraKeys = extraKeys.filter((key) => {\n            return !options.excludeKeys(key);\n          });\n        }\n        write(\"object:\" + (keys.length + extraKeys.length) + \":\");\n        const dispatchForKey = (key) => {\n          this.dispatch(key);\n          write(\":\");\n          if (!options.excludeValues) {\n            this.dispatch(object[key]);\n          }\n          write(\",\");\n        };\n        for (const key of keys) {\n          dispatchForKey(key);\n        }\n        for (const key of extraKeys) {\n          dispatchForKey(key);\n        }\n      }\n    },\n    array(arr, unordered) {\n      unordered = unordered === void 0 ? options.unorderedArrays !== false : unordered;\n      write(\"array:\" + arr.length + \":\");\n      if (!unordered || arr.length <= 1) {\n        for (const entry of arr) {\n          this.dispatch(entry);\n        }\n        return;\n      }\n      const contextAdditions = /* @__PURE__ */ new Map();\n      const entries = arr.map((entry) => {\n        const hasher = createHasher(options);\n        hasher.dispatch(entry);\n        for (const [key, value] of hasher.getContext()) {\n          contextAdditions.set(key, value);\n        }\n        return hasher.toString();\n      });\n      context = contextAdditions;\n      entries.sort();\n      return this.array(entries, false);\n    },\n    date(date) {\n      return write(\"date:\" + date.toJSON());\n    },\n    symbol(sym) {\n      return write(\"symbol:\" + sym.toString());\n    },\n    unkown(value, type) {\n      write(type);\n      if (!value) {\n        return;\n      }\n      write(\":\");\n      if (value && typeof value.entries === \"function\") {\n        return this.array(\n          Array.from(value.entries()),\n          true\n          /* ordered */\n        );\n      }\n    },\n    error(err) {\n      return write(\"error:\" + err.toString());\n    },\n    boolean(bool) {\n      return write(\"bool:\" + bool);\n    },\n    string(string) {\n      write(\"string:\" + string.length + \":\");\n      write(string);\n    },\n    function(fn) {\n      write(\"fn:\");\n      if (isNativeFunction(fn)) {\n        this.dispatch(\"[native]\");\n      } else {\n        this.dispatch(fn.toString());\n      }\n      if (options.respectFunctionNames !== false) {\n        this.dispatch(\"function-name:\" + String(fn.name));\n      }\n      if (options.respectFunctionProperties) {\n        this.object(fn);\n      }\n    },\n    number(number) {\n      return write(\"number:\" + number);\n    },\n    xml(xml) {\n      return write(\"xml:\" + xml.toString());\n    },\n    null() {\n      return write(\"Null\");\n    },\n    undefined() {\n      return write(\"Undefined\");\n    },\n    regexp(regex) {\n      return write(\"regex:\" + regex.toString());\n    },\n    uint8array(arr) {\n      write(\"uint8array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    uint8clampedarray(arr) {\n      write(\"uint8clampedarray:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    int8array(arr) {\n      write(\"int8array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    uint16array(arr) {\n      write(\"uint16array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    int16array(arr) {\n      write(\"int16array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    uint32array(arr) {\n      write(\"uint32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    int32array(arr) {\n      write(\"int32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    float32array(arr) {\n      write(\"float32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    float64array(arr) {\n      write(\"float64array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    arraybuffer(arr) {\n      write(\"arraybuffer:\");\n      return this.dispatch(new Uint8Array(arr));\n    },\n    url(url) {\n      return write(\"url:\" + url.toString());\n    },\n    map(map) {\n      write(\"map:\");\n      const arr = [...map];\n      return this.array(arr, options.unorderedSets !== false);\n    },\n    set(set) {\n      write(\"set:\");\n      const arr = [...set];\n      return this.array(arr, options.unorderedSets !== false);\n    },\n    file(file) {\n      write(\"file:\");\n      return this.dispatch([file.name, file.size, file.type, file.lastModfied]);\n    },\n    blob() {\n      if (options.ignoreUnknown) {\n        return write(\"[blob]\");\n      }\n      throw new Error(\n        'Hashing Blob objects is currently not supported\\nUse \"options.replacer\" or \"options.ignoreUnknown\"\\n'\n      );\n    },\n    domwindow() {\n      return write(\"domwindow\");\n    },\n    bigint(number) {\n      return write(\"bigint:\" + number.toString());\n    },\n    /* Node.js standard native objects */\n    process() {\n      return write(\"process\");\n    },\n    timer() {\n      return write(\"timer\");\n    },\n    pipe() {\n      return write(\"pipe\");\n    },\n    tcp() {\n      return write(\"tcp\");\n    },\n    udp() {\n      return write(\"udp\");\n    },\n    tty() {\n      return write(\"tty\");\n    },\n    statwatcher() {\n      return write(\"statwatcher\");\n    },\n    securecontext() {\n      return write(\"securecontext\");\n    },\n    connection() {\n      return write(\"connection\");\n    },\n    zlib() {\n      return write(\"zlib\");\n    },\n    context() {\n      return write(\"context\");\n    },\n    nodescript() {\n      return write(\"nodescript\");\n    },\n    httpparser() {\n      return write(\"httpparser\");\n    },\n    dataview() {\n      return write(\"dataview\");\n    },\n    signal() {\n      return write(\"signal\");\n    },\n    fsevent() {\n      return write(\"fsevent\");\n    },\n    tlswrap() {\n      return write(\"tlswrap\");\n    }\n  };\n}\nconst nativeFunc = \"[native code] }\";\nconst nativeFuncLength = nativeFunc.length;\nfunction isNativeFunction(f) {\n  if (typeof f !== \"function\") {\n    return false;\n  }\n  return Function.prototype.toString.call(f).slice(-nativeFuncLength) === nativeFunc;\n}\n\nclass WordArray {\n  constructor(words, sigBytes) {\n    words = this.words = words || [];\n    this.sigBytes = sigBytes === void 0 ? words.length * 4 : sigBytes;\n  }\n  toString(encoder) {\n    return (encoder || Hex).stringify(this);\n  }\n  concat(wordArray) {\n    this.clamp();\n    if (this.sigBytes % 4) {\n      for (let i = 0; i < wordArray.sigBytes; i++) {\n        const thatByte = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n        this.words[this.sigBytes + i >>> 2] |= thatByte << 24 - (this.sigBytes + i) % 4 * 8;\n      }\n    } else {\n      for (let j = 0; j < wordArray.sigBytes; j += 4) {\n        this.words[this.sigBytes + j >>> 2] = wordArray.words[j >>> 2];\n      }\n    }\n    this.sigBytes += wordArray.sigBytes;\n    return this;\n  }\n  clamp() {\n    this.words[this.sigBytes >>> 2] &= 4294967295 << 32 - this.sigBytes % 4 * 8;\n    this.words.length = Math.ceil(this.sigBytes / 4);\n  }\n  clone() {\n    return new WordArray([...this.words]);\n  }\n}\nconst Hex = {\n  stringify(wordArray) {\n    const hexChars = [];\n    for (let i = 0; i < wordArray.sigBytes; i++) {\n      const bite = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n      hexChars.push((bite >>> 4).toString(16), (bite & 15).toString(16));\n    }\n    return hexChars.join(\"\");\n  }\n};\nconst Base64 = {\n  stringify(wordArray) {\n    const keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    const base64Chars = [];\n    for (let i = 0; i < wordArray.sigBytes; i += 3) {\n      const byte1 = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n      const byte2 = wordArray.words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;\n      const byte3 = wordArray.words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;\n      const triplet = byte1 << 16 | byte2 << 8 | byte3;\n      for (let j = 0; j < 4 && i * 8 + j * 6 < wordArray.sigBytes * 8; j++) {\n        base64Chars.push(keyStr.charAt(triplet >>> 6 * (3 - j) & 63));\n      }\n    }\n    return base64Chars.join(\"\");\n  }\n};\nconst Latin1 = {\n  parse(latin1Str) {\n    const latin1StrLength = latin1Str.length;\n    const words = [];\n    for (let i = 0; i < latin1StrLength; i++) {\n      words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;\n    }\n    return new WordArray(words, latin1StrLength);\n  }\n};\nconst Utf8 = {\n  parse(utf8Str) {\n    return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n  }\n};\nclass BufferedBlockAlgorithm {\n  constructor() {\n    this._data = new WordArray();\n    this._nDataBytes = 0;\n    this._minBufferSize = 0;\n    this.blockSize = 512 / 32;\n  }\n  reset() {\n    this._data = new WordArray();\n    this._nDataBytes = 0;\n  }\n  _append(data) {\n    if (typeof data === \"string\") {\n      data = Utf8.parse(data);\n    }\n    this._data.concat(data);\n    this._nDataBytes += data.sigBytes;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _doProcessBlock(_dataWords, _offset) {\n  }\n  _process(doFlush) {\n    let processedWords;\n    let nBlocksReady = this._data.sigBytes / (this.blockSize * 4);\n    if (doFlush) {\n      nBlocksReady = Math.ceil(nBlocksReady);\n    } else {\n      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n    }\n    const nWordsReady = nBlocksReady * this.blockSize;\n    const nBytesReady = Math.min(nWordsReady * 4, this._data.sigBytes);\n    if (nWordsReady) {\n      for (let offset = 0; offset < nWordsReady; offset += this.blockSize) {\n        this._doProcessBlock(this._data.words, offset);\n      }\n      processedWords = this._data.words.splice(0, nWordsReady);\n      this._data.sigBytes -= nBytesReady;\n    }\n    return new WordArray(processedWords, nBytesReady);\n  }\n}\nclass Hasher extends BufferedBlockAlgorithm {\n  update(messageUpdate) {\n    this._append(messageUpdate);\n    this._process();\n    return this;\n  }\n  finalize(messageUpdate) {\n    if (messageUpdate) {\n      this._append(messageUpdate);\n    }\n  }\n}\n\nconst H = [\n  1779033703,\n  -1150833019,\n  1013904242,\n  -1521486534,\n  1359893119,\n  -1694144372,\n  528734635,\n  1541459225\n];\nconst K = [\n  1116352408,\n  1899447441,\n  -1245643825,\n  -373957723,\n  961987163,\n  1508970993,\n  -1841331548,\n  -1424204075,\n  -670586216,\n  310598401,\n  607225278,\n  1426881987,\n  1925078388,\n  -2132889090,\n  -1680079193,\n  -1046744716,\n  -459576895,\n  -272742522,\n  264347078,\n  604807628,\n  770255983,\n  1249150122,\n  1555081692,\n  1996064986,\n  -1740746414,\n  -1473132947,\n  -1341970488,\n  -1084653625,\n  -958395405,\n  -710438585,\n  113926993,\n  338241895,\n  666307205,\n  773529912,\n  1294757372,\n  1396182291,\n  1695183700,\n  1986661051,\n  -2117940946,\n  -1838011259,\n  -1564481375,\n  -1474664885,\n  -1035236496,\n  -949202525,\n  -778901479,\n  -694614492,\n  -200395387,\n  275423344,\n  430227734,\n  506948616,\n  659060556,\n  883997877,\n  958139571,\n  1322822218,\n  1537002063,\n  1747873779,\n  1955562222,\n  2024104815,\n  -2067236844,\n  -1933114872,\n  -1866530822,\n  -1538233109,\n  -1090935817,\n  -965641998\n];\nconst W = [];\nclass SHA256 extends Hasher {\n  constructor() {\n    super(...arguments);\n    this._hash = new WordArray([...H]);\n  }\n  reset() {\n    super.reset();\n    this._hash = new WordArray([...H]);\n  }\n  _doProcessBlock(M, offset) {\n    const H2 = this._hash.words;\n    let a = H2[0];\n    let b = H2[1];\n    let c = H2[2];\n    let d = H2[3];\n    let e = H2[4];\n    let f = H2[5];\n    let g = H2[6];\n    let h = H2[7];\n    for (let i = 0; i < 64; i++) {\n      if (i < 16) {\n        W[i] = M[offset + i] | 0;\n      } else {\n        const gamma0x = W[i - 15];\n        const gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;\n        const gamma1x = W[i - 2];\n        const gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;\n        W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n      }\n      const ch = e & f ^ ~e & g;\n      const maj = a & b ^ a & c ^ b & c;\n      const sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);\n      const sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);\n      const t1 = h + sigma1 + ch + K[i] + W[i];\n      const t2 = sigma0 + maj;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t1 | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t1 + t2 | 0;\n    }\n    H2[0] = H2[0] + a | 0;\n    H2[1] = H2[1] + b | 0;\n    H2[2] = H2[2] + c | 0;\n    H2[3] = H2[3] + d | 0;\n    H2[4] = H2[4] + e | 0;\n    H2[5] = H2[5] + f | 0;\n    H2[6] = H2[6] + g | 0;\n    H2[7] = H2[7] + h | 0;\n  }\n  finalize(messageUpdate) {\n    super.finalize(messageUpdate);\n    const nBitsTotal = this._nDataBytes * 8;\n    const nBitsLeft = this._data.sigBytes * 8;\n    this._data.words[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;\n    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(\n      nBitsTotal / 4294967296\n    );\n    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;\n    this._data.sigBytes = this._data.words.length * 4;\n    this._process();\n    return this._hash;\n  }\n}\nfunction sha256base64(message) {\n  return new SHA256().finalize(message).toString(Base64);\n}\n\nfunction hash(object, options = {}) {\n  const hashed = typeof object === \"string\" ? object : objectHash(object, options);\n  return sha256base64(hashed).slice(0, 10);\n}\n\nasync function generateBuild(ctx, config) {\n  const {\n    outputDir = \".vite-inspect\"\n  } = ctx.options;\n  const targetDir = isAbsolute(outputDir) ? outputDir : resolve(config.root, outputDir);\n  const reportsDir = join(targetDir, \"reports\");\n  await fs.emptyDir(targetDir);\n  await fs.ensureDir(reportsDir);\n  await fs.copy(DIR_CLIENT, targetDir);\n  const isVirtual = (pluginName, transformName) => pluginName !== DUMMY_LOAD_PLUGIN_NAME && transformName !== \"vite:load-fallback\";\n  function list() {\n    return {\n      root: config.root,\n      modules: ctx.getModulesInfo(ctx.recorderClient, null, isVirtual),\n      ssrModules: ctx.getModulesInfo(ctx.recorderServer, null, isVirtual)\n    };\n  }\n  async function dumpModuleInfo(dir, recorder, ssr = false) {\n    await fs.ensureDir(dir);\n    return Promise.all(\n      Object.entries(recorder.transform).map(\n        ([id, info]) => fs.writeJSON(\n          join(dir, `${hash(id)}.json`),\n          {\n            resolvedId: ctx.resolveId(id, ssr),\n            transforms: info\n          },\n          { spaces: 2 }\n        )\n      )\n    );\n  }\n  await Promise.all([\n    fs.writeFile(\n      join(targetDir, \"index.html\"),\n      (await fs.readFile(join(targetDir, \"index.html\"), \"utf-8\")).replace(\n        'data-vite-inspect-mode=\"DEV\"',\n        'data-vite-inspect-mode=\"BUILD\"'\n      )\n    ),\n    fs.writeJSON(\n      join(reportsDir, \"list.json\"),\n      list(),\n      { spaces: 2 }\n    ),\n    fs.writeJSON(\n      join(reportsDir, \"metrics.json\"),\n      ctx.getPluginMetrics(false),\n      { spaces: 2 }\n    ),\n    fs.writeJSON(\n      join(reportsDir, \"metrics-ssr.json\"),\n      ctx.getPluginMetrics(true),\n      { spaces: 2 }\n    ),\n    dumpModuleInfo(join(reportsDir, \"transform\"), ctx.recorderClient),\n    dumpModuleInfo(join(reportsDir, \"transform-ssr\"), ctx.recorderServer, true)\n  ]);\n  return targetDir;\n}\n\nasync function openBrowser(address) {\n  await import('open').then((r) => r.default(address, { newInstance: true })).catch(() => {\n  });\n}\n\nfunction createPreviewServer(staticPath) {\n  const server = createServer();\n  const statics = sirv(staticPath);\n  server.on(\"request\", (req, res) => {\n    statics(req, res, () => {\n      res.statusCode = 404;\n      res.end(\"File not found\");\n    });\n  });\n  server.listen(0, () => {\n    const { port } = server.address();\n    const url = `http://localhost:${port}`;\n    console.log(`  ${c.green(\"\\u279C\")}  ${c.bold(\"Inspect Preview Started\")}: ${url}`);\n    openBrowser(url);\n  });\n}\n\nconst NAME = \"vite-plugin-inspect\";\nconst isCI = !!process.env.CI;\nfunction PluginInspect(options = {}) {\n  const {\n    dev = true,\n    build = false,\n    silent = false,\n    open: _open = false\n  } = options;\n  if (!dev && !build) {\n    return {\n      name: NAME\n    };\n  }\n  const ctx = new ViteInspectContext(options);\n  const timestampRE = /\\bt=\\d{13}&?\\b/;\n  const trailingSeparatorRE = /[?&]$/;\n  let config;\n  const serverPerf = {\n    middleware: {}\n  };\n  function setupMiddlewarePerf(middlewares) {\n    let firstMiddlewareIndex = -1;\n    middlewares.forEach((middleware, index) => {\n      const { handle: originalHandle } = middleware;\n      if (typeof originalHandle !== \"function\" || !originalHandle.name)\n        return middleware;\n      middleware.handle = (...middlewareArgs) => {\n        var _a;\n        let req;\n        if (middlewareArgs.length === 4)\n          [, req] = middlewareArgs;\n        else\n          [req] = middlewareArgs;\n        const start = Date.now();\n        const url = req.url?.replace(timestampRE, \"\").replace(trailingSeparatorRE, \"\");\n        (_a = serverPerf.middleware)[url] ?? (_a[url] = []);\n        if (firstMiddlewareIndex < 0)\n          firstMiddlewareIndex = index;\n        if (index === firstMiddlewareIndex)\n          serverPerf.middleware[url] = [];\n        const result = originalHandle(...middlewareArgs);\n        Promise.resolve(result).then(() => {\n          const total = Date.now() - start;\n          const metrics = serverPerf.middleware[url];\n          serverPerf.middleware[url].push({\n            self: metrics.length ? Math.max(total - metrics[metrics.length - 1].total, 0) : total,\n            total,\n            name: originalHandle.name\n          });\n        });\n        return result;\n      };\n      Object.defineProperty(middleware.handle, \"name\", {\n        value: originalHandle.name,\n        configurable: true,\n        enumerable: true\n      });\n      return middleware;\n    });\n  }\n  function configureServer(server) {\n    const _invalidateModule = server.moduleGraph.invalidateModule;\n    server.moduleGraph.invalidateModule = function(...args) {\n      const mod = args[0];\n      if (mod?.id) {\n        ctx.recorderClient.invalidate(mod.id);\n        ctx.recorderServer.invalidate(mod.id);\n      }\n      return _invalidateModule.apply(this, args);\n    };\n    const base = (options.base ?? server.config.base) || \"/\";\n    server.middlewares.use(`${base}__inspect`, sirv(DIR_CLIENT, {\n      single: true,\n      dev: true\n    }));\n    const rpcFunctions = {\n      list: () => ctx.getList(server),\n      getIdInfo,\n      getPluginMetrics: (ssr = false) => ctx.getPluginMetrics(ssr),\n      getServerMetrics,\n      resolveId: (id, ssr = false) => ctx.resolveId(id, ssr),\n      clear: clearId,\n      moduleUpdated: () => {\n      }\n    };\n    const rpcServer = createRPCServer(\"vite-plugin-inspect\", server.ws, rpcFunctions);\n    const debouncedModuleUpdated = debounce(() => {\n      rpcServer.moduleUpdated.asEvent();\n    }, 100);\n    server.middlewares.use((req, res, next) => {\n      debouncedModuleUpdated();\n      next();\n    });\n    function getServerMetrics() {\n      return serverPerf || {};\n    }\n    async function getIdInfo(id, ssr = false, clear = false) {\n      if (clear) {\n        clearId(id, ssr);\n        try {\n          await server.transformRequest(id, { ssr });\n        } catch {\n        }\n      }\n      const resolvedId = ctx.resolveId(id, ssr);\n      const recorder = ctx.getRecorder(ssr);\n      return {\n        resolvedId,\n        transforms: recorder.transform[resolvedId] || []\n      };\n    }\n    function clearId(_id, ssr = false) {\n      const id = ctx.resolveId(_id);\n      if (id) {\n        const mod = server.moduleGraph.getModuleById(id);\n        if (mod)\n          server.moduleGraph.invalidateModule(mod);\n        ctx.getRecorder(ssr).invalidate(id);\n      }\n    }\n    const _print = server.printUrls;\n    server.printUrls = () => {\n      let host = `${config.server.https ? \"https\" : \"http\"}://localhost:${config.server.port || \"80\"}`;\n      const url = server.resolvedUrls?.local[0];\n      if (url) {\n        try {\n          const u = new URL(url);\n          host = `${u.protocol}//${u.host}`;\n        } catch (error) {\n          console.warn(\"Parse resolved url failed:\", error);\n        }\n      }\n      _print();\n      if (!silent) {\n        const colorUrl = (url2) => c.green(url2.replace(/:(\\d+)\\//, (_, port) => `:${c.bold(port)}/`));\n        console.log(`  ${c.green(\"\\u279C\")}  ${c.bold(\"Inspect\")}: ${colorUrl(`${host}${base}__inspect/`)}`);\n      }\n      if (_open && !isCI) {\n        setTimeout(() => {\n          openBrowser(`${host}${base}__inspect/`);\n        }, 500);\n      }\n    };\n    return rpcFunctions;\n  }\n  const plugin = {\n    name: NAME,\n    enforce: \"pre\",\n    apply(_, { command }) {\n      if (command === \"serve\" && dev)\n        return true;\n      if (command === \"build\" && build)\n        return true;\n      return false;\n    },\n    configResolved(_config) {\n      config = ctx.config = _config;\n      config.plugins.forEach((plugin2) => hijackPlugin(plugin2, ctx));\n      const _createResolver = config.createResolver;\n      config.createResolver = function(...args) {\n        const _resolver = _createResolver.apply(this, args);\n        return async function(...args2) {\n          const id = args2[0];\n          const aliasOnly = args2[2];\n          const ssr = args2[3];\n          const start = Date.now();\n          const result = await _resolver.apply(this, args2);\n          const end = Date.now();\n          if (result && result !== id) {\n            const pluginName = aliasOnly ? \"alias\" : \"vite:resolve (+alias)\";\n            ctx.getRecorder(ssr).recordResolveId(id, { name: pluginName, result, start, end });\n          }\n          return result;\n        };\n      };\n    },\n    configureServer(server) {\n      const rpc = configureServer(server);\n      plugin.api = {\n        rpc\n      };\n      return () => {\n        setupMiddlewarePerf(server.middlewares.stack);\n      };\n    },\n    load: {\n      order: \"pre\",\n      handler(id, { ssr } = {}) {\n        ctx.getRecorder(ssr).invalidate(id);\n        return null;\n      }\n    },\n    handleHotUpdate({ modules, server }) {\n      const ids = modules.map((module) => module.id);\n      server.ws.send({\n        type: \"custom\",\n        event: \"vite-plugin-inspect:update\",\n        data: { ids }\n      });\n    },\n    async buildEnd() {\n      if (!build)\n        return;\n      const dir = await generateBuild(ctx, config);\n      console.log(c.green(\"Inspect report generated at\"), c.dim(`${dir}`));\n      if (_open && !isCI)\n        createPreviewServer(dir);\n    }\n  };\n  return plugin;\n}\nPluginInspect.getViteInspectAPI = function(plugins) {\n  return plugins.find((p) => p.name === NAME)?.api;\n};\n\nexport { PluginInspect as default };\n",
      "start": 1718972211394,
      "end": 1718972211396,
      "sourcemaps": null
    },
    {
      "name": "vite:css",
      "start": 1718972211396,
      "end": 1718972211396,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1718972211396,
      "end": 1718972211396,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1718972211396,
      "end": 1718972211396,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1718972211396,
      "end": 1718972211396,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import process from \"node:process\";\nimport sirv from \"sirv\";\nimport c from \"picocolors\";\nimport { debounce } from \"perfect-debounce\";\nimport { dirname, resolve, isAbsolute, join } from \"node:path\";\nimport { fileURLToPath } from \"node:url\";\nimport { Buffer as Buffer$1 } from \"node:buffer\";\nimport { createFilter } from \"@rollup/pluginutils\";\nimport Debug from \"debug\";\nimport { parse } from \"error-stack-parser-es\";\nimport fs from \"fs-extra\";\nimport { createServer } from \"node:http\";\nconst DEFAULT_TIMEOUT = 6e4;\nfunction defaultSerialize(i) {\n  return i;\n}\nconst defaultDeserialize = defaultSerialize;\nconst { clearTimeout, setTimeout: setTimeout$1 } = globalThis;\nconst random = Math.random.bind(Math);\nfunction createBirpc(functions, options) {\n  const {\n    post,\n    on,\n    eventNames = [],\n    serialize = defaultSerialize,\n    deserialize = defaultDeserialize,\n    resolver,\n    timeout = DEFAULT_TIMEOUT\n  } = options;\n  const rpcPromiseMap = /* @__PURE__ */ new Map();\n  let _promise;\n  const rpc = new Proxy({}, {\n    get(_, method) {\n      if (method === \"$functions\")\n        return functions;\n      const sendEvent = (...args) => {\n        post(serialize({ m: method, a: args, t: \"q\" }));\n      };\n      if (eventNames.includes(method)) {\n        sendEvent.asEvent = sendEvent;\n        return sendEvent;\n      }\n      const sendCall = async (...args) => {\n        await _promise;\n        return new Promise((resolve2, reject) => {\n          const id = nanoid();\n          let timeoutId;\n          if (timeout >= 0) {\n            timeoutId = setTimeout$1(() => {\n              reject(new Error(`[birpc] timeout on calling \"${method}\"`));\n              rpcPromiseMap.delete(id);\n            }, timeout).unref?.();\n          }\n          rpcPromiseMap.set(id, { resolve: resolve2, reject, timeoutId });\n          post(serialize({ m: method, a: args, i: id, t: \"q\" }));\n        });\n      };\n      sendCall.asEvent = sendEvent;\n      return sendCall;\n    }\n  });\n  _promise = on(async (data, ...extra) => {\n    const msg = deserialize(data);\n    if (msg.t === \"q\") {\n      const { m: method, a: args } = msg;\n      let result, error;\n      const fn = resolver ? resolver(method, functions[method]) : functions[method];\n      if (!fn) {\n        error = new Error(`[birpc] function \"${method}\" not found`);\n      } else {\n        try {\n          result = await fn.apply(rpc, args);\n        } catch (e) {\n          error = e;\n        }\n      }\n      if (msg.i) {\n        if (error && options.onError)\n          options.onError(error, method, args);\n        post(serialize({ t: \"s\", i: msg.i, r: result, e: error }), ...extra);\n      }\n    } else {\n      const { i: ack, r: result, e: error } = msg;\n      const promise = rpcPromiseMap.get(ack);\n      if (promise) {\n        clearTimeout(promise.timeoutId);\n        if (error)\n          promise.reject(error);\n        else\n          promise.resolve(result);\n      }\n      rpcPromiseMap.delete(ack);\n    }\n  });\n  return rpc;\n}\nconst cacheMap = /* @__PURE__ */ new WeakMap();\nfunction cachedMap(items, fn) {\n  return items.map((i) => {\n    let r = cacheMap.get(i);\n    if (!r) {\n      r = fn(i);\n      cacheMap.set(i, r);\n    }\n    return r;\n  });\n}\nfunction createBirpcGroup(functions, channels, options = {}) {\n  const getChannels = () => typeof channels === \"function\" ? channels() : channels;\n  const getClients = (channels2 = getChannels()) => cachedMap(channels2, (s) => createBirpc(functions, { ...options, ...s }));\n  const broadcastProxy = new Proxy({}, {\n    get(_, method) {\n      const client = getClients();\n      const callbacks = client.map((c2) => c2[method]);\n      const sendCall = (...args) => {\n        return Promise.all(callbacks.map((i) => i(...args)));\n      };\n      sendCall.asEvent = (...args) => {\n        callbacks.map((i) => i.asEvent(...args));\n      };\n      return sendCall;\n    }\n  });\n  function updateChannels(fn) {\n    const channels2 = getChannels();\n    fn?.(channels2);\n    return getClients(channels2);\n  }\n  getClients();\n  return {\n    get clients() {\n      return getClients();\n    },\n    functions,\n    updateChannels,\n    broadcast: broadcastProxy,\n    /**\n     * @deprecated use `broadcast`\n     */\n    // @ts-expect-error deprecated\n    boardcast: broadcastProxy\n  };\n}\nconst urlAlphabet = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nfunction nanoid(size = 21) {\n  let id = \"\";\n  let i = size;\n  while (i--)\n    id += urlAlphabet[random() * 64 | 0];\n  return id;\n}\nfunction createRPCServer(name, ws, functions, options = {}) {\n  const event = `${name}:rpc`;\n  const group = createBirpcGroup(\n    functions,\n    () => cachedMap(\n      Array.from(ws?.clients || []),\n      (socket) => {\n        return {\n          on: (fn) => {\n            ws.on(event, (data, source) => {\n              if (socket === source)\n                fn(data);\n            });\n          },\n          post: (data) => {\n            socket.send(event, data);\n          }\n        };\n      }\n    ),\n    options\n  );\n  ws.on(\"connection\", () => {\n    group.updateChannels();\n  });\n  return group.broadcast;\n}\nconst DIR_DIST = typeof __dirname !== \"undefined\" ? __dirname : dirname(fileURLToPath(import.meta.url));\nconst DIR_CLIENT = resolve(DIR_DIST, \"../dist/client\");\nconst DUMMY_LOAD_PLUGIN_NAME = \"__load__\";\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => {\n  __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass Recorder {\n  constructor() {\n    __publicField$1(this, \"transform\", {});\n    __publicField$1(this, \"resolveId\", {});\n    __publicField$1(this, \"transformCounter\", {});\n  }\n  recordTransform(id, info, preTransformCode) {\n    if (!this.transform[id] || !this.transform[id].some((tr) => tr.result)) {\n      this.transform[id] = [{\n        name: DUMMY_LOAD_PLUGIN_NAME,\n        result: preTransformCode,\n        start: info.start,\n        end: info.start,\n        sourcemaps: info.sourcemaps\n      }];\n      this.transformCounter[id] = (this.transformCounter[id] || 0) + 1;\n    }\n    this.transform[id].push(info);\n  }\n  recordLoad(id, info) {\n    this.transform[id] = [info];\n    this.transformCounter[id] = (this.transformCounter[id] || 0) + 1;\n  }\n  recordResolveId(id, info) {\n    if (!this.resolveId[id])\n      this.resolveId[id] = [];\n    this.resolveId[id].push(info);\n  }\n  invalidate(id) {\n    delete this.transform[id];\n  }\n}\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass ViteInspectContext {\n  constructor(options) {\n    this.options = options;\n    __publicField(this, \"filter\");\n    __publicField(this, \"config\");\n    __publicField(this, \"recorderClient\", new Recorder());\n    __publicField(this, \"recorderServer\", new Recorder());\n    this.filter = createFilter(options.include, options.exclude);\n  }\n  getRecorder(ssr) {\n    return ssr ? this.recorderServer : this.recorderClient;\n  }\n  resolveId(id = \"\", ssr = false) {\n    if (id.startsWith(\"./\"))\n      id = resolve(this.config.root, id).replace(/\\\\/g, \"/\");\n    return this.resolveIdRecursive(id, ssr);\n  }\n  resolveIdRecursive(id, ssr = false) {\n    const rec = this.getRecorder(ssr);\n    const resolved = rec.resolveId[id]?.[0]?.result;\n    return resolved ? this.resolveIdRecursive(resolved, ssr) : id;\n  }\n  getList(server) {\n    const isVirtual = (pluginName) => pluginName !== DUMMY_LOAD_PLUGIN_NAME;\n    const getDeps = (id) => Array.from(server.moduleGraph.getModuleById(id)?.importedModules || []).map((i) => i.id || \"\").filter(Boolean);\n    return {\n      root: this.config.root,\n      modules: this.getModulesInfo(this.recorderClient, getDeps, isVirtual),\n      ssrModules: this.getModulesInfo(this.recorderServer, getDeps, isVirtual)\n    };\n  }\n  getModulesInfo(recorder, getDeps, isVirtual) {\n    function transformIdMap(recorder2) {\n      return Object.values(recorder2.resolveId).reduce((map, ids2) => {\n        ids2.forEach((id) => {\n          var _a;\n          map[_a = id.result] ?? (map[_a] = []);\n          map[id.result].push(id);\n        });\n        return map;\n      }, {});\n    }\n    const transformedIdMap = transformIdMap(recorder);\n    const ids = new Set(Object.keys(recorder.transform).concat(Object.keys(transformedIdMap)));\n    return Array.from(ids).sort().map((id) => {\n      let totalTime = 0;\n      const plugins = (recorder.transform[id] || []).filter((tr) => tr.result).map((transItem) => {\n        const delta = transItem.end - transItem.start;\n        totalTime += delta;\n        return { name: transItem.name, transform: delta };\n      }).concat(\n        // @ts-expect-error transform is optional\n        (transformedIdMap[id] || []).map((idItem) => {\n          return { name: idItem.name, resolveId: idItem.end - idItem.start };\n        })\n      );\n      function getSize(str) {\n        if (!str)\n          return 0;\n        return Buffer$1.byteLength(str, \"utf8\");\n      }\n      return {\n        id,\n        deps: getDeps ? getDeps(id) : [],\n        plugins,\n        virtual: isVirtual(plugins[0]?.name || \"\", recorder.transform[id]?.[0].name || \"\"),\n        totalTime,\n        invokeCount: recorder.transformCounter?.[id] || 0,\n        sourceSize: getSize(recorder.transform[id]?.[0]?.result),\n        distSize: getSize(recorder.transform[id]?.[recorder.transform[id].length - 1]?.result)\n      };\n    });\n  }\n  getPluginMetrics(ssr = false) {\n    const map = {};\n    const defaultMetricInfo = () => ({\n      transform: { invokeCount: 0, totalTime: 0 },\n      resolveId: { invokeCount: 0, totalTime: 0 }\n    });\n    this.config.plugins.forEach((i) => {\n      map[i.name] = {\n        ...defaultMetricInfo(),\n        name: i.name,\n        enforce: i.enforce\n      };\n    });\n    const recorder = this.getRecorder(ssr);\n    Object.values(recorder.transform).forEach((transformInfos) => {\n      transformInfos.forEach(({ name, start, end }) => {\n        if (name === DUMMY_LOAD_PLUGIN_NAME)\n          return;\n        if (!map[name])\n          map[name] = { ...defaultMetricInfo(), name };\n        map[name].transform.totalTime += end - start;\n        map[name].transform.invokeCount += 1;\n      });\n    });\n    Object.values(recorder.resolveId).forEach((resolveIdInfos) => {\n      resolveIdInfos.forEach(({ name, start, end }) => {\n        if (!map[name])\n          map[name] = { ...defaultMetricInfo(), name };\n        map[name].resolveId.totalTime += end - start;\n        map[name].resolveId.invokeCount += 1;\n      });\n    });\n    const metrics = Object.values(map).filter(Boolean).sort((a, b) => a.name.localeCompare(b.name));\n    return metrics;\n  }\n}\nconst debug = Debug(\"vite-plugin-inspect\");\nfunction hijackHook(plugin, name, wrapper) {\n  if (!plugin[name])\n    return;\n  debug(`hijack plugin \"${name}\"`, plugin.name);\n  let order = plugin.order || plugin.enforce || \"normal\";\n  const hook = plugin[name];\n  if (\"handler\" in hook) {\n    const oldFn = hook.handler;\n    order += `-${hook.order || hook.enforce || \"normal\"}`;\n    hook.handler = function(...args) {\n      return wrapper(oldFn, this, args, order);\n    };\n  } else if (\"transform\" in hook) {\n    const oldFn = hook.transform;\n    order += `-${hook.order || hook.enforce || \"normal\"}`;\n    hook.transform = function(...args) {\n      return wrapper(oldFn, this, args, order);\n    };\n  } else {\n    const oldFn = hook;\n    plugin[name] = function(...args) {\n      return wrapper(oldFn, this, args, order);\n    };\n  }\n}\nfunction hijackPlugin(plugin, ctx) {\n  hijackHook(plugin, \"transform\", async (fn, context, args, order) => {\n    const code = args[0];\n    const id = args[1];\n    const ssr = args[2]?.ssr;\n    let _result;\n    let error;\n    const start = Date.now();\n    try {\n      _result = await fn.apply(context, args);\n    } catch (_err) {\n      error = _err;\n    }\n    const end = Date.now();\n    const result = error ? \"[Error]\" : typeof _result === \"string\" ? _result : _result?.code;\n    if (ctx.filter(id)) {\n      const sourcemaps = typeof _result === \"string\" ? null : _result?.map;\n      const rec = ctx.getRecorder(ssr);\n      rec.recordTransform(id, {\n        name: plugin.name,\n        result,\n        start,\n        end,\n        order,\n        sourcemaps,\n        error: error ? parseError(error) : void 0\n      }, code);\n    }\n    if (error)\n      throw error;\n    return _result;\n  });\n  hijackHook(plugin, \"load\", async (fn, context, args) => {\n    const id = args[0];\n    const ssr = args[1]?.ssr;\n    let _result;\n    let error;\n    const start = Date.now();\n    try {\n      _result = await fn.apply(context, args);\n    } catch (err) {\n      error = err;\n    }\n    const end = Date.now();\n    const result = error ? \"[Error]\" : typeof _result === \"string\" ? _result : _result?.code;\n    const sourcemaps = typeof _result === \"string\" ? null : _result?.map;\n    if (result) {\n      ctx.getRecorder(ssr).recordLoad(id, {\n        name: plugin.name,\n        result,\n        start,\n        end,\n        sourcemaps,\n        error: error ? parseError(error) : void 0\n      });\n    }\n    if (error)\n      throw error;\n    return _result;\n  });\n  hijackHook(plugin, \"resolveId\", async (fn, context, args) => {\n    const id = args[0];\n    const ssr = args[2]?.ssr;\n    let _result;\n    let error;\n    const start = Date.now();\n    try {\n      _result = await fn.apply(context, args);\n    } catch (err) {\n      error = err;\n    }\n    const end = Date.now();\n    if (!ctx.filter(id)) {\n      if (error)\n        throw error;\n      return _result;\n    }\n    const result = error ? stringifyError(error) : typeof _result === \"object\" ? _result?.id : _result;\n    if (result && result !== id) {\n      ctx.getRecorder(ssr).recordResolveId(id, {\n        name: plugin.name,\n        result,\n        start,\n        end,\n        error\n      });\n    }\n    if (error)\n      throw error;\n    return _result;\n  });\n}\nfunction parseError(error) {\n  const stack = parse(error);\n  const message = error.message || String(error);\n  return {\n    message,\n    stack,\n    raw: error\n  };\n}\nfunction stringifyError(err) {\n  return String(err.stack ? err.stack : err);\n}\nconst defaults = Object.freeze({\n  ignoreUnknown: false,\n  respectType: false,\n  respectFunctionNames: false,\n  respectFunctionProperties: false,\n  unorderedObjects: true,\n  unorderedArrays: false,\n  unorderedSets: false,\n  excludeKeys: void 0,\n  excludeValues: void 0,\n  replacer: void 0\n});\nfunction objectHash(object, options) {\n  if (options) {\n    options = { ...defaults, ...options };\n  } else {\n    options = defaults;\n  }\n  const hasher = createHasher(options);\n  hasher.dispatch(object);\n  return hasher.toString();\n}\nconst defaultPrototypesKeys = Object.freeze([\n  \"prototype\",\n  \"__proto__\",\n  \"constructor\"\n]);\nfunction createHasher(options) {\n  let buff = \"\";\n  let context = /* @__PURE__ */ new Map();\n  const write = (str) => {\n    buff += str;\n  };\n  return {\n    toString() {\n      return buff;\n    },\n    getContext() {\n      return context;\n    },\n    dispatch(value) {\n      if (options.replacer) {\n        value = options.replacer(value);\n      }\n      const type = value === null ? \"null\" : typeof value;\n      return this[type](value);\n    },\n    object(object) {\n      if (object && typeof object.toJSON === \"function\") {\n        return this.object(object.toJSON());\n      }\n      const objString = Object.prototype.toString.call(object);\n      let objType = \"\";\n      const objectLength = objString.length;\n      if (objectLength < 10) {\n        objType = \"unknown:[\" + objString + \"]\";\n      } else {\n        objType = objString.slice(8, objectLength - 1);\n      }\n      objType = objType.toLowerCase();\n      let objectNumber = null;\n      if ((objectNumber = context.get(object)) === void 0) {\n        context.set(object, context.size);\n      } else {\n        return this.dispatch(\"[CIRCULAR:\" + objectNumber + \"]\");\n      }\n      if (typeof Buffer !== \"undefined\" && Buffer.isBuffer && Buffer.isBuffer(object)) {\n        write(\"buffer:\");\n        return write(object.toString(\"utf8\"));\n      }\n      if (objType !== \"object\" && objType !== \"function\" && objType !== \"asyncfunction\") {\n        if (this[objType]) {\n          this[objType](object);\n        } else if (!options.ignoreUnknown) {\n          this.unkown(object, objType);\n        }\n      } else {\n        let keys = Object.keys(object);\n        if (options.unorderedObjects) {\n          keys = keys.sort();\n        }\n        let extraKeys = [];\n        if (options.respectType !== false && !isNativeFunction(object)) {\n          extraKeys = defaultPrototypesKeys;\n        }\n        if (options.excludeKeys) {\n          keys = keys.filter((key) => {\n            return !options.excludeKeys(key);\n          });\n          extraKeys = extraKeys.filter((key) => {\n            return !options.excludeKeys(key);\n          });\n        }\n        write(\"object:\" + (keys.length + extraKeys.length) + \":\");\n        const dispatchForKey = (key) => {\n          this.dispatch(key);\n          write(\":\");\n          if (!options.excludeValues) {\n            this.dispatch(object[key]);\n          }\n          write(\",\");\n        };\n        for (const key of keys) {\n          dispatchForKey(key);\n        }\n        for (const key of extraKeys) {\n          dispatchForKey(key);\n        }\n      }\n    },\n    array(arr, unordered) {\n      unordered = unordered === void 0 ? options.unorderedArrays !== false : unordered;\n      write(\"array:\" + arr.length + \":\");\n      if (!unordered || arr.length <= 1) {\n        for (const entry of arr) {\n          this.dispatch(entry);\n        }\n        return;\n      }\n      const contextAdditions = /* @__PURE__ */ new Map();\n      const entries = arr.map((entry) => {\n        const hasher = createHasher(options);\n        hasher.dispatch(entry);\n        for (const [key, value] of hasher.getContext()) {\n          contextAdditions.set(key, value);\n        }\n        return hasher.toString();\n      });\n      context = contextAdditions;\n      entries.sort();\n      return this.array(entries, false);\n    },\n    date(date) {\n      return write(\"date:\" + date.toJSON());\n    },\n    symbol(sym) {\n      return write(\"symbol:\" + sym.toString());\n    },\n    unkown(value, type) {\n      write(type);\n      if (!value) {\n        return;\n      }\n      write(\":\");\n      if (value && typeof value.entries === \"function\") {\n        return this.array(\n          Array.from(value.entries()),\n          true\n          /* ordered */\n        );\n      }\n    },\n    error(err) {\n      return write(\"error:\" + err.toString());\n    },\n    boolean(bool) {\n      return write(\"bool:\" + bool);\n    },\n    string(string) {\n      write(\"string:\" + string.length + \":\");\n      write(string);\n    },\n    function(fn) {\n      write(\"fn:\");\n      if (isNativeFunction(fn)) {\n        this.dispatch(\"[native]\");\n      } else {\n        this.dispatch(fn.toString());\n      }\n      if (options.respectFunctionNames !== false) {\n        this.dispatch(\"function-name:\" + String(fn.name));\n      }\n      if (options.respectFunctionProperties) {\n        this.object(fn);\n      }\n    },\n    number(number) {\n      return write(\"number:\" + number);\n    },\n    xml(xml) {\n      return write(\"xml:\" + xml.toString());\n    },\n    null() {\n      return write(\"Null\");\n    },\n    undefined() {\n      return write(\"Undefined\");\n    },\n    regexp(regex) {\n      return write(\"regex:\" + regex.toString());\n    },\n    uint8array(arr) {\n      write(\"uint8array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    uint8clampedarray(arr) {\n      write(\"uint8clampedarray:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    int8array(arr) {\n      write(\"int8array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    uint16array(arr) {\n      write(\"uint16array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    int16array(arr) {\n      write(\"int16array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    uint32array(arr) {\n      write(\"uint32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    int32array(arr) {\n      write(\"int32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    float32array(arr) {\n      write(\"float32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    float64array(arr) {\n      write(\"float64array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    arraybuffer(arr) {\n      write(\"arraybuffer:\");\n      return this.dispatch(new Uint8Array(arr));\n    },\n    url(url) {\n      return write(\"url:\" + url.toString());\n    },\n    map(map) {\n      write(\"map:\");\n      const arr = [...map];\n      return this.array(arr, options.unorderedSets !== false);\n    },\n    set(set) {\n      write(\"set:\");\n      const arr = [...set];\n      return this.array(arr, options.unorderedSets !== false);\n    },\n    file(file) {\n      write(\"file:\");\n      return this.dispatch([file.name, file.size, file.type, file.lastModfied]);\n    },\n    blob() {\n      if (options.ignoreUnknown) {\n        return write(\"[blob]\");\n      }\n      throw new Error(\n        'Hashing Blob objects is currently not supported\\nUse \"options.replacer\" or \"options.ignoreUnknown\"\\n'\n      );\n    },\n    domwindow() {\n      return write(\"domwindow\");\n    },\n    bigint(number) {\n      return write(\"bigint:\" + number.toString());\n    },\n    /* Node.js standard native objects */\n    process() {\n      return write(\"process\");\n    },\n    timer() {\n      return write(\"timer\");\n    },\n    pipe() {\n      return write(\"pipe\");\n    },\n    tcp() {\n      return write(\"tcp\");\n    },\n    udp() {\n      return write(\"udp\");\n    },\n    tty() {\n      return write(\"tty\");\n    },\n    statwatcher() {\n      return write(\"statwatcher\");\n    },\n    securecontext() {\n      return write(\"securecontext\");\n    },\n    connection() {\n      return write(\"connection\");\n    },\n    zlib() {\n      return write(\"zlib\");\n    },\n    context() {\n      return write(\"context\");\n    },\n    nodescript() {\n      return write(\"nodescript\");\n    },\n    httpparser() {\n      return write(\"httpparser\");\n    },\n    dataview() {\n      return write(\"dataview\");\n    },\n    signal() {\n      return write(\"signal\");\n    },\n    fsevent() {\n      return write(\"fsevent\");\n    },\n    tlswrap() {\n      return write(\"tlswrap\");\n    }\n  };\n}\nconst nativeFunc = \"[native code] }\";\nconst nativeFuncLength = nativeFunc.length;\nfunction isNativeFunction(f) {\n  if (typeof f !== \"function\") {\n    return false;\n  }\n  return Function.prototype.toString.call(f).slice(-nativeFuncLength) === nativeFunc;\n}\nclass WordArray {\n  constructor(words, sigBytes) {\n    words = this.words = words || [];\n    this.sigBytes = sigBytes === void 0 ? words.length * 4 : sigBytes;\n  }\n  toString(encoder) {\n    return (encoder || Hex).stringify(this);\n  }\n  concat(wordArray) {\n    this.clamp();\n    if (this.sigBytes % 4) {\n      for (let i = 0; i < wordArray.sigBytes; i++) {\n        const thatByte = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n        this.words[this.sigBytes + i >>> 2] |= thatByte << 24 - (this.sigBytes + i) % 4 * 8;\n      }\n    } else {\n      for (let j = 0; j < wordArray.sigBytes; j += 4) {\n        this.words[this.sigBytes + j >>> 2] = wordArray.words[j >>> 2];\n      }\n    }\n    this.sigBytes += wordArray.sigBytes;\n    return this;\n  }\n  clamp() {\n    this.words[this.sigBytes >>> 2] &= 4294967295 << 32 - this.sigBytes % 4 * 8;\n    this.words.length = Math.ceil(this.sigBytes / 4);\n  }\n  clone() {\n    return new WordArray([...this.words]);\n  }\n}\nconst Hex = {\n  stringify(wordArray) {\n    const hexChars = [];\n    for (let i = 0; i < wordArray.sigBytes; i++) {\n      const bite = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n      hexChars.push((bite >>> 4).toString(16), (bite & 15).toString(16));\n    }\n    return hexChars.join(\"\");\n  }\n};\nconst Base64 = {\n  stringify(wordArray) {\n    const keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    const base64Chars = [];\n    for (let i = 0; i < wordArray.sigBytes; i += 3) {\n      const byte1 = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n      const byte2 = wordArray.words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;\n      const byte3 = wordArray.words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;\n      const triplet = byte1 << 16 | byte2 << 8 | byte3;\n      for (let j = 0; j < 4 && i * 8 + j * 6 < wordArray.sigBytes * 8; j++) {\n        base64Chars.push(keyStr.charAt(triplet >>> 6 * (3 - j) & 63));\n      }\n    }\n    return base64Chars.join(\"\");\n  }\n};\nconst Latin1 = {\n  parse(latin1Str) {\n    const latin1StrLength = latin1Str.length;\n    const words = [];\n    for (let i = 0; i < latin1StrLength; i++) {\n      words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;\n    }\n    return new WordArray(words, latin1StrLength);\n  }\n};\nconst Utf8 = {\n  parse(utf8Str) {\n    return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n  }\n};\nclass BufferedBlockAlgorithm {\n  constructor() {\n    this._data = new WordArray();\n    this._nDataBytes = 0;\n    this._minBufferSize = 0;\n    this.blockSize = 512 / 32;\n  }\n  reset() {\n    this._data = new WordArray();\n    this._nDataBytes = 0;\n  }\n  _append(data) {\n    if (typeof data === \"string\") {\n      data = Utf8.parse(data);\n    }\n    this._data.concat(data);\n    this._nDataBytes += data.sigBytes;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _doProcessBlock(_dataWords, _offset) {\n  }\n  _process(doFlush) {\n    let processedWords;\n    let nBlocksReady = this._data.sigBytes / (this.blockSize * 4);\n    if (doFlush) {\n      nBlocksReady = Math.ceil(nBlocksReady);\n    } else {\n      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n    }\n    const nWordsReady = nBlocksReady * this.blockSize;\n    const nBytesReady = Math.min(nWordsReady * 4, this._data.sigBytes);\n    if (nWordsReady) {\n      for (let offset = 0; offset < nWordsReady; offset += this.blockSize) {\n        this._doProcessBlock(this._data.words, offset);\n      }\n      processedWords = this._data.words.splice(0, nWordsReady);\n      this._data.sigBytes -= nBytesReady;\n    }\n    return new WordArray(processedWords, nBytesReady);\n  }\n}\nclass Hasher extends BufferedBlockAlgorithm {\n  update(messageUpdate) {\n    this._append(messageUpdate);\n    this._process();\n    return this;\n  }\n  finalize(messageUpdate) {\n    if (messageUpdate) {\n      this._append(messageUpdate);\n    }\n  }\n}\nconst H = [\n  1779033703,\n  -1150833019,\n  1013904242,\n  -1521486534,\n  1359893119,\n  -1694144372,\n  528734635,\n  1541459225\n];\nconst K = [\n  1116352408,\n  1899447441,\n  -1245643825,\n  -373957723,\n  961987163,\n  1508970993,\n  -1841331548,\n  -1424204075,\n  -670586216,\n  310598401,\n  607225278,\n  1426881987,\n  1925078388,\n  -2132889090,\n  -1680079193,\n  -1046744716,\n  -459576895,\n  -272742522,\n  264347078,\n  604807628,\n  770255983,\n  1249150122,\n  1555081692,\n  1996064986,\n  -1740746414,\n  -1473132947,\n  -1341970488,\n  -1084653625,\n  -958395405,\n  -710438585,\n  113926993,\n  338241895,\n  666307205,\n  773529912,\n  1294757372,\n  1396182291,\n  1695183700,\n  1986661051,\n  -2117940946,\n  -1838011259,\n  -1564481375,\n  -1474664885,\n  -1035236496,\n  -949202525,\n  -778901479,\n  -694614492,\n  -200395387,\n  275423344,\n  430227734,\n  506948616,\n  659060556,\n  883997877,\n  958139571,\n  1322822218,\n  1537002063,\n  1747873779,\n  1955562222,\n  2024104815,\n  -2067236844,\n  -1933114872,\n  -1866530822,\n  -1538233109,\n  -1090935817,\n  -965641998\n];\nconst W = [];\nclass SHA256 extends Hasher {\n  constructor() {\n    super(...arguments);\n    this._hash = new WordArray([...H]);\n  }\n  reset() {\n    super.reset();\n    this._hash = new WordArray([...H]);\n  }\n  _doProcessBlock(M, offset) {\n    const H2 = this._hash.words;\n    let a = H2[0];\n    let b = H2[1];\n    let c2 = H2[2];\n    let d = H2[3];\n    let e = H2[4];\n    let f = H2[5];\n    let g = H2[6];\n    let h = H2[7];\n    for (let i = 0; i < 64; i++) {\n      if (i < 16) {\n        W[i] = M[offset + i] | 0;\n      } else {\n        const gamma0x = W[i - 15];\n        const gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;\n        const gamma1x = W[i - 2];\n        const gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;\n        W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n      }\n      const ch = e & f ^ ~e & g;\n      const maj = a & b ^ a & c2 ^ b & c2;\n      const sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);\n      const sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);\n      const t1 = h + sigma1 + ch + K[i] + W[i];\n      const t2 = sigma0 + maj;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t1 | 0;\n      d = c2;\n      c2 = b;\n      b = a;\n      a = t1 + t2 | 0;\n    }\n    H2[0] = H2[0] + a | 0;\n    H2[1] = H2[1] + b | 0;\n    H2[2] = H2[2] + c2 | 0;\n    H2[3] = H2[3] + d | 0;\n    H2[4] = H2[4] + e | 0;\n    H2[5] = H2[5] + f | 0;\n    H2[6] = H2[6] + g | 0;\n    H2[7] = H2[7] + h | 0;\n  }\n  finalize(messageUpdate) {\n    super.finalize(messageUpdate);\n    const nBitsTotal = this._nDataBytes * 8;\n    const nBitsLeft = this._data.sigBytes * 8;\n    this._data.words[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;\n    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(\n      nBitsTotal / 4294967296\n    );\n    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;\n    this._data.sigBytes = this._data.words.length * 4;\n    this._process();\n    return this._hash;\n  }\n}\nfunction sha256base64(message) {\n  return new SHA256().finalize(message).toString(Base64);\n}\nfunction hash(object, options = {}) {\n  const hashed = typeof object === \"string\" ? object : objectHash(object, options);\n  return sha256base64(hashed).slice(0, 10);\n}\nasync function generateBuild(ctx, config) {\n  const {\n    outputDir = \".vite-inspect\"\n  } = ctx.options;\n  const targetDir = isAbsolute(outputDir) ? outputDir : resolve(config.root, outputDir);\n  const reportsDir = join(targetDir, \"reports\");\n  await fs.emptyDir(targetDir);\n  await fs.ensureDir(reportsDir);\n  await fs.copy(DIR_CLIENT, targetDir);\n  const isVirtual = (pluginName, transformName) => pluginName !== DUMMY_LOAD_PLUGIN_NAME && transformName !== \"vite:load-fallback\";\n  function list() {\n    return {\n      root: config.root,\n      modules: ctx.getModulesInfo(ctx.recorderClient, null, isVirtual),\n      ssrModules: ctx.getModulesInfo(ctx.recorderServer, null, isVirtual)\n    };\n  }\n  async function dumpModuleInfo(dir, recorder, ssr = false) {\n    await fs.ensureDir(dir);\n    return Promise.all(\n      Object.entries(recorder.transform).map(\n        ([id, info]) => fs.writeJSON(\n          join(dir, `${hash(id)}.json`),\n          {\n            resolvedId: ctx.resolveId(id, ssr),\n            transforms: info\n          },\n          { spaces: 2 }\n        )\n      )\n    );\n  }\n  await Promise.all([\n    fs.writeFile(\n      join(targetDir, \"index.html\"),\n      (await fs.readFile(join(targetDir, \"index.html\"), \"utf-8\")).replace(\n        'data-vite-inspect-mode=\"DEV\"',\n        'data-vite-inspect-mode=\"BUILD\"'\n      )\n    ),\n    fs.writeJSON(\n      join(reportsDir, \"list.json\"),\n      list(),\n      { spaces: 2 }\n    ),\n    fs.writeJSON(\n      join(reportsDir, \"metrics.json\"),\n      ctx.getPluginMetrics(false),\n      { spaces: 2 }\n    ),\n    fs.writeJSON(\n      join(reportsDir, \"metrics-ssr.json\"),\n      ctx.getPluginMetrics(true),\n      { spaces: 2 }\n    ),\n    dumpModuleInfo(join(reportsDir, \"transform\"), ctx.recorderClient),\n    dumpModuleInfo(join(reportsDir, \"transform-ssr\"), ctx.recorderServer, true)\n  ]);\n  return targetDir;\n}\nasync function openBrowser(address) {\n  await import(\"open\").then((r) => r.default(address, { newInstance: true })).catch(() => {\n  });\n}\nfunction createPreviewServer(staticPath) {\n  const server = createServer();\n  const statics = sirv(staticPath);\n  server.on(\"request\", (req, res) => {\n    statics(req, res, () => {\n      res.statusCode = 404;\n      res.end(\"File not found\");\n    });\n  });\n  server.listen(0, () => {\n    const { port } = server.address();\n    const url = `http://localhost:${port}`;\n    console.log(`  ${c.green(\"\")}  ${c.bold(\"Inspect Preview Started\")}: ${url}`);\n    openBrowser(url);\n  });\n}\nconst NAME = \"vite-plugin-inspect\";\nconst isCI = !!process.env.CI;\nfunction PluginInspect(options = {}) {\n  const {\n    dev = true,\n    build = false,\n    silent = false,\n    open: _open = false\n  } = options;\n  if (!dev && !build) {\n    return {\n      name: NAME\n    };\n  }\n  const ctx = new ViteInspectContext(options);\n  const timestampRE = /\\bt=\\d{13}&?\\b/;\n  const trailingSeparatorRE = /[?&]$/;\n  let config;\n  const serverPerf = {\n    middleware: {}\n  };\n  function setupMiddlewarePerf(middlewares) {\n    let firstMiddlewareIndex = -1;\n    middlewares.forEach((middleware, index) => {\n      const { handle: originalHandle } = middleware;\n      if (typeof originalHandle !== \"function\" || !originalHandle.name)\n        return middleware;\n      middleware.handle = (...middlewareArgs) => {\n        var _a;\n        let req;\n        if (middlewareArgs.length === 4)\n          [, req] = middlewareArgs;\n        else\n          [req] = middlewareArgs;\n        const start = Date.now();\n        const url = req.url?.replace(timestampRE, \"\").replace(trailingSeparatorRE, \"\");\n        (_a = serverPerf.middleware)[url] ?? (_a[url] = []);\n        if (firstMiddlewareIndex < 0)\n          firstMiddlewareIndex = index;\n        if (index === firstMiddlewareIndex)\n          serverPerf.middleware[url] = [];\n        const result = originalHandle(...middlewareArgs);\n        Promise.resolve(result).then(() => {\n          const total = Date.now() - start;\n          const metrics = serverPerf.middleware[url];\n          serverPerf.middleware[url].push({\n            self: metrics.length ? Math.max(total - metrics[metrics.length - 1].total, 0) : total,\n            total,\n            name: originalHandle.name\n          });\n        });\n        return result;\n      };\n      Object.defineProperty(middleware.handle, \"name\", {\n        value: originalHandle.name,\n        configurable: true,\n        enumerable: true\n      });\n      return middleware;\n    });\n  }\n  function configureServer(server) {\n    const _invalidateModule = server.moduleGraph.invalidateModule;\n    server.moduleGraph.invalidateModule = function(...args) {\n      const mod = args[0];\n      if (mod?.id) {\n        ctx.recorderClient.invalidate(mod.id);\n        ctx.recorderServer.invalidate(mod.id);\n      }\n      return _invalidateModule.apply(this, args);\n    };\n    const base = (options.base ?? server.config.base) || \"/\";\n    server.middlewares.use(`${base}__inspect`, sirv(DIR_CLIENT, {\n      single: true,\n      dev: true\n    }));\n    const rpcFunctions = {\n      list: () => ctx.getList(server),\n      getIdInfo,\n      getPluginMetrics: (ssr = false) => ctx.getPluginMetrics(ssr),\n      getServerMetrics,\n      resolveId: (id, ssr = false) => ctx.resolveId(id, ssr),\n      clear: clearId,\n      moduleUpdated: () => {\n      }\n    };\n    const rpcServer = createRPCServer(\"vite-plugin-inspect\", server.ws, rpcFunctions);\n    const debouncedModuleUpdated = debounce(() => {\n      rpcServer.moduleUpdated.asEvent();\n    }, 100);\n    server.middlewares.use((req, res, next) => {\n      debouncedModuleUpdated();\n      next();\n    });\n    function getServerMetrics() {\n      return serverPerf || {};\n    }\n    async function getIdInfo(id, ssr = false, clear = false) {\n      if (clear) {\n        clearId(id, ssr);\n        try {\n          await server.transformRequest(id, { ssr });\n        } catch {\n        }\n      }\n      const resolvedId = ctx.resolveId(id, ssr);\n      const recorder = ctx.getRecorder(ssr);\n      return {\n        resolvedId,\n        transforms: recorder.transform[resolvedId] || []\n      };\n    }\n    function clearId(_id, ssr = false) {\n      const id = ctx.resolveId(_id);\n      if (id) {\n        const mod = server.moduleGraph.getModuleById(id);\n        if (mod)\n          server.moduleGraph.invalidateModule(mod);\n        ctx.getRecorder(ssr).invalidate(id);\n      }\n    }\n    const _print = server.printUrls;\n    server.printUrls = () => {\n      let host = `${config.server.https ? \"https\" : \"http\"}://localhost:${config.server.port || \"80\"}`;\n      const url = server.resolvedUrls?.local[0];\n      if (url) {\n        try {\n          const u = new URL(url);\n          host = `${u.protocol}//${u.host}`;\n        } catch (error) {\n          console.warn(\"Parse resolved url failed:\", error);\n        }\n      }\n      _print();\n      if (!silent) {\n        const colorUrl = (url2) => c.green(url2.replace(/:(\\d+)\\//, (_, port) => `:${c.bold(port)}/`));\n        console.log(`  ${c.green(\"\")}  ${c.bold(\"Inspect\")}: ${colorUrl(`${host}${base}__inspect/`)}`);\n      }\n      if (_open && !isCI) {\n        setTimeout(() => {\n          openBrowser(`${host}${base}__inspect/`);\n        }, 500);\n      }\n    };\n    return rpcFunctions;\n  }\n  const plugin = {\n    name: NAME,\n    enforce: \"pre\",\n    apply(_, { command }) {\n      if (command === \"serve\" && dev)\n        return true;\n      if (command === \"build\" && build)\n        return true;\n      return false;\n    },\n    configResolved(_config) {\n      config = ctx.config = _config;\n      config.plugins.forEach((plugin2) => hijackPlugin(plugin2, ctx));\n      const _createResolver = config.createResolver;\n      config.createResolver = function(...args) {\n        const _resolver = _createResolver.apply(this, args);\n        return async function(...args2) {\n          const id = args2[0];\n          const aliasOnly = args2[2];\n          const ssr = args2[3];\n          const start = Date.now();\n          const result = await _resolver.apply(this, args2);\n          const end = Date.now();\n          if (result && result !== id) {\n            const pluginName = aliasOnly ? \"alias\" : \"vite:resolve (+alias)\";\n            ctx.getRecorder(ssr).recordResolveId(id, { name: pluginName, result, start, end });\n          }\n          return result;\n        };\n      };\n    },\n    configureServer(server) {\n      const rpc = configureServer(server);\n      plugin.api = {\n        rpc\n      };\n      return () => {\n        setupMiddlewarePerf(server.middlewares.stack);\n      };\n    },\n    load: {\n      order: \"pre\",\n      handler(id, { ssr } = {}) {\n        ctx.getRecorder(ssr).invalidate(id);\n        return null;\n      }\n    },\n    handleHotUpdate({ modules, server }) {\n      const ids = modules.map((module) => module.id);\n      server.ws.send({\n        type: \"custom\",\n        event: \"vite-plugin-inspect:update\",\n        data: { ids }\n      });\n    },\n    async buildEnd() {\n      if (!build)\n        return;\n      const dir = await generateBuild(ctx, config);\n      console.log(c.green(\"Inspect report generated at\"), c.dim(`${dir}`));\n      if (_open && !isCI)\n        createPreviewServer(dir);\n    }\n  };\n  return plugin;\n}\nPluginInspect.getViteInspectAPI = function(plugins) {\n  return plugins.find((p) => p.name === NAME)?.api;\n};\nexport { PluginInspect as default };\n",
      "start": 1718972211396,
      "end": 1718972211402,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "vite:css-post",
      "start": 1718972211402,
      "end": 1718972211402,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1718972211402,
      "end": 1718972211402,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1718972211402,
      "end": 1718972211402,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1718972211402,
      "end": 1718972211415,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1718972211415,
      "end": 1718972211415,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1718972211415,
      "end": 1718972211415,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1718972211415,
      "end": 1718972211415,
      "order": "normal"
    },
    {
      "name": "vite:build-import-analysis",
      "result": "import { __vitePreload } from \"\u0000vite/preload-helper.js\";import process from \"node:process\";\nimport sirv from \"sirv\";\nimport c from \"picocolors\";\nimport { debounce } from \"perfect-debounce\";\nimport { dirname, resolve, isAbsolute, join } from \"node:path\";\nimport { fileURLToPath } from \"node:url\";\nimport { Buffer as Buffer$1 } from \"node:buffer\";\nimport { createFilter } from \"@rollup/pluginutils\";\nimport Debug from \"debug\";\nimport { parse } from \"error-stack-parser-es\";\nimport fs from \"fs-extra\";\nimport { createServer } from \"node:http\";\nconst DEFAULT_TIMEOUT = 6e4;\nfunction defaultSerialize(i) {\n  return i;\n}\nconst defaultDeserialize = defaultSerialize;\nconst { clearTimeout, setTimeout: setTimeout$1 } = globalThis;\nconst random = Math.random.bind(Math);\nfunction createBirpc(functions, options) {\n  const {\n    post,\n    on,\n    eventNames = [],\n    serialize = defaultSerialize,\n    deserialize = defaultDeserialize,\n    resolver,\n    timeout = DEFAULT_TIMEOUT\n  } = options;\n  const rpcPromiseMap = /* @__PURE__ */ new Map();\n  let _promise;\n  const rpc = new Proxy({}, {\n    get(_, method) {\n      if (method === \"$functions\")\n        return functions;\n      const sendEvent = (...args) => {\n        post(serialize({ m: method, a: args, t: \"q\" }));\n      };\n      if (eventNames.includes(method)) {\n        sendEvent.asEvent = sendEvent;\n        return sendEvent;\n      }\n      const sendCall = async (...args) => {\n        await _promise;\n        return new Promise((resolve2, reject) => {\n          const id = nanoid();\n          let timeoutId;\n          if (timeout >= 0) {\n            timeoutId = setTimeout$1(() => {\n              reject(new Error(`[birpc] timeout on calling \"${method}\"`));\n              rpcPromiseMap.delete(id);\n            }, timeout).unref?.();\n          }\n          rpcPromiseMap.set(id, { resolve: resolve2, reject, timeoutId });\n          post(serialize({ m: method, a: args, i: id, t: \"q\" }));\n        });\n      };\n      sendCall.asEvent = sendEvent;\n      return sendCall;\n    }\n  });\n  _promise = on(async (data, ...extra) => {\n    const msg = deserialize(data);\n    if (msg.t === \"q\") {\n      const { m: method, a: args } = msg;\n      let result, error;\n      const fn = resolver ? resolver(method, functions[method]) : functions[method];\n      if (!fn) {\n        error = new Error(`[birpc] function \"${method}\" not found`);\n      } else {\n        try {\n          result = await fn.apply(rpc, args);\n        } catch (e) {\n          error = e;\n        }\n      }\n      if (msg.i) {\n        if (error && options.onError)\n          options.onError(error, method, args);\n        post(serialize({ t: \"s\", i: msg.i, r: result, e: error }), ...extra);\n      }\n    } else {\n      const { i: ack, r: result, e: error } = msg;\n      const promise = rpcPromiseMap.get(ack);\n      if (promise) {\n        clearTimeout(promise.timeoutId);\n        if (error)\n          promise.reject(error);\n        else\n          promise.resolve(result);\n      }\n      rpcPromiseMap.delete(ack);\n    }\n  });\n  return rpc;\n}\nconst cacheMap = /* @__PURE__ */ new WeakMap();\nfunction cachedMap(items, fn) {\n  return items.map((i) => {\n    let r = cacheMap.get(i);\n    if (!r) {\n      r = fn(i);\n      cacheMap.set(i, r);\n    }\n    return r;\n  });\n}\nfunction createBirpcGroup(functions, channels, options = {}) {\n  const getChannels = () => typeof channels === \"function\" ? channels() : channels;\n  const getClients = (channels2 = getChannels()) => cachedMap(channels2, (s) => createBirpc(functions, { ...options, ...s }));\n  const broadcastProxy = new Proxy({}, {\n    get(_, method) {\n      const client = getClients();\n      const callbacks = client.map((c2) => c2[method]);\n      const sendCall = (...args) => {\n        return Promise.all(callbacks.map((i) => i(...args)));\n      };\n      sendCall.asEvent = (...args) => {\n        callbacks.map((i) => i.asEvent(...args));\n      };\n      return sendCall;\n    }\n  });\n  function updateChannels(fn) {\n    const channels2 = getChannels();\n    fn?.(channels2);\n    return getClients(channels2);\n  }\n  getClients();\n  return {\n    get clients() {\n      return getClients();\n    },\n    functions,\n    updateChannels,\n    broadcast: broadcastProxy,\n    /**\n     * @deprecated use `broadcast`\n     */\n    // @ts-expect-error deprecated\n    boardcast: broadcastProxy\n  };\n}\nconst urlAlphabet = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nfunction nanoid(size = 21) {\n  let id = \"\";\n  let i = size;\n  while (i--)\n    id += urlAlphabet[random() * 64 | 0];\n  return id;\n}\nfunction createRPCServer(name, ws, functions, options = {}) {\n  const event = `${name}:rpc`;\n  const group = createBirpcGroup(\n    functions,\n    () => cachedMap(\n      Array.from(ws?.clients || []),\n      (socket) => {\n        return {\n          on: (fn) => {\n            ws.on(event, (data, source) => {\n              if (socket === source)\n                fn(data);\n            });\n          },\n          post: (data) => {\n            socket.send(event, data);\n          }\n        };\n      }\n    ),\n    options\n  );\n  ws.on(\"connection\", () => {\n    group.updateChannels();\n  });\n  return group.broadcast;\n}\nconst DIR_DIST = typeof __dirname !== \"undefined\" ? __dirname : dirname(fileURLToPath(import.meta.url));\nconst DIR_CLIENT = resolve(DIR_DIST, \"../dist/client\");\nconst DUMMY_LOAD_PLUGIN_NAME = \"__load__\";\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => {\n  __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass Recorder {\n  constructor() {\n    __publicField$1(this, \"transform\", {});\n    __publicField$1(this, \"resolveId\", {});\n    __publicField$1(this, \"transformCounter\", {});\n  }\n  recordTransform(id, info, preTransformCode) {\n    if (!this.transform[id] || !this.transform[id].some((tr) => tr.result)) {\n      this.transform[id] = [{\n        name: DUMMY_LOAD_PLUGIN_NAME,\n        result: preTransformCode,\n        start: info.start,\n        end: info.start,\n        sourcemaps: info.sourcemaps\n      }];\n      this.transformCounter[id] = (this.transformCounter[id] || 0) + 1;\n    }\n    this.transform[id].push(info);\n  }\n  recordLoad(id, info) {\n    this.transform[id] = [info];\n    this.transformCounter[id] = (this.transformCounter[id] || 0) + 1;\n  }\n  recordResolveId(id, info) {\n    if (!this.resolveId[id])\n      this.resolveId[id] = [];\n    this.resolveId[id].push(info);\n  }\n  invalidate(id) {\n    delete this.transform[id];\n  }\n}\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass ViteInspectContext {\n  constructor(options) {\n    this.options = options;\n    __publicField(this, \"filter\");\n    __publicField(this, \"config\");\n    __publicField(this, \"recorderClient\", new Recorder());\n    __publicField(this, \"recorderServer\", new Recorder());\n    this.filter = createFilter(options.include, options.exclude);\n  }\n  getRecorder(ssr) {\n    return ssr ? this.recorderServer : this.recorderClient;\n  }\n  resolveId(id = \"\", ssr = false) {\n    if (id.startsWith(\"./\"))\n      id = resolve(this.config.root, id).replace(/\\\\/g, \"/\");\n    return this.resolveIdRecursive(id, ssr);\n  }\n  resolveIdRecursive(id, ssr = false) {\n    const rec = this.getRecorder(ssr);\n    const resolved = rec.resolveId[id]?.[0]?.result;\n    return resolved ? this.resolveIdRecursive(resolved, ssr) : id;\n  }\n  getList(server) {\n    const isVirtual = (pluginName) => pluginName !== DUMMY_LOAD_PLUGIN_NAME;\n    const getDeps = (id) => Array.from(server.moduleGraph.getModuleById(id)?.importedModules || []).map((i) => i.id || \"\").filter(Boolean);\n    return {\n      root: this.config.root,\n      modules: this.getModulesInfo(this.recorderClient, getDeps, isVirtual),\n      ssrModules: this.getModulesInfo(this.recorderServer, getDeps, isVirtual)\n    };\n  }\n  getModulesInfo(recorder, getDeps, isVirtual) {\n    function transformIdMap(recorder2) {\n      return Object.values(recorder2.resolveId).reduce((map, ids2) => {\n        ids2.forEach((id) => {\n          var _a;\n          map[_a = id.result] ?? (map[_a] = []);\n          map[id.result].push(id);\n        });\n        return map;\n      }, {});\n    }\n    const transformedIdMap = transformIdMap(recorder);\n    const ids = new Set(Object.keys(recorder.transform).concat(Object.keys(transformedIdMap)));\n    return Array.from(ids).sort().map((id) => {\n      let totalTime = 0;\n      const plugins = (recorder.transform[id] || []).filter((tr) => tr.result).map((transItem) => {\n        const delta = transItem.end - transItem.start;\n        totalTime += delta;\n        return { name: transItem.name, transform: delta };\n      }).concat(\n        // @ts-expect-error transform is optional\n        (transformedIdMap[id] || []).map((idItem) => {\n          return { name: idItem.name, resolveId: idItem.end - idItem.start };\n        })\n      );\n      function getSize(str) {\n        if (!str)\n          return 0;\n        return Buffer$1.byteLength(str, \"utf8\");\n      }\n      return {\n        id,\n        deps: getDeps ? getDeps(id) : [],\n        plugins,\n        virtual: isVirtual(plugins[0]?.name || \"\", recorder.transform[id]?.[0].name || \"\"),\n        totalTime,\n        invokeCount: recorder.transformCounter?.[id] || 0,\n        sourceSize: getSize(recorder.transform[id]?.[0]?.result),\n        distSize: getSize(recorder.transform[id]?.[recorder.transform[id].length - 1]?.result)\n      };\n    });\n  }\n  getPluginMetrics(ssr = false) {\n    const map = {};\n    const defaultMetricInfo = () => ({\n      transform: { invokeCount: 0, totalTime: 0 },\n      resolveId: { invokeCount: 0, totalTime: 0 }\n    });\n    this.config.plugins.forEach((i) => {\n      map[i.name] = {\n        ...defaultMetricInfo(),\n        name: i.name,\n        enforce: i.enforce\n      };\n    });\n    const recorder = this.getRecorder(ssr);\n    Object.values(recorder.transform).forEach((transformInfos) => {\n      transformInfos.forEach(({ name, start, end }) => {\n        if (name === DUMMY_LOAD_PLUGIN_NAME)\n          return;\n        if (!map[name])\n          map[name] = { ...defaultMetricInfo(), name };\n        map[name].transform.totalTime += end - start;\n        map[name].transform.invokeCount += 1;\n      });\n    });\n    Object.values(recorder.resolveId).forEach((resolveIdInfos) => {\n      resolveIdInfos.forEach(({ name, start, end }) => {\n        if (!map[name])\n          map[name] = { ...defaultMetricInfo(), name };\n        map[name].resolveId.totalTime += end - start;\n        map[name].resolveId.invokeCount += 1;\n      });\n    });\n    const metrics = Object.values(map).filter(Boolean).sort((a, b) => a.name.localeCompare(b.name));\n    return metrics;\n  }\n}\nconst debug = Debug(\"vite-plugin-inspect\");\nfunction hijackHook(plugin, name, wrapper) {\n  if (!plugin[name])\n    return;\n  debug(`hijack plugin \"${name}\"`, plugin.name);\n  let order = plugin.order || plugin.enforce || \"normal\";\n  const hook = plugin[name];\n  if (\"handler\" in hook) {\n    const oldFn = hook.handler;\n    order += `-${hook.order || hook.enforce || \"normal\"}`;\n    hook.handler = function(...args) {\n      return wrapper(oldFn, this, args, order);\n    };\n  } else if (\"transform\" in hook) {\n    const oldFn = hook.transform;\n    order += `-${hook.order || hook.enforce || \"normal\"}`;\n    hook.transform = function(...args) {\n      return wrapper(oldFn, this, args, order);\n    };\n  } else {\n    const oldFn = hook;\n    plugin[name] = function(...args) {\n      return wrapper(oldFn, this, args, order);\n    };\n  }\n}\nfunction hijackPlugin(plugin, ctx) {\n  hijackHook(plugin, \"transform\", async (fn, context, args, order) => {\n    const code = args[0];\n    const id = args[1];\n    const ssr = args[2]?.ssr;\n    let _result;\n    let error;\n    const start = Date.now();\n    try {\n      _result = await fn.apply(context, args);\n    } catch (_err) {\n      error = _err;\n    }\n    const end = Date.now();\n    const result = error ? \"[Error]\" : typeof _result === \"string\" ? _result : _result?.code;\n    if (ctx.filter(id)) {\n      const sourcemaps = typeof _result === \"string\" ? null : _result?.map;\n      const rec = ctx.getRecorder(ssr);\n      rec.recordTransform(id, {\n        name: plugin.name,\n        result,\n        start,\n        end,\n        order,\n        sourcemaps,\n        error: error ? parseError(error) : void 0\n      }, code);\n    }\n    if (error)\n      throw error;\n    return _result;\n  });\n  hijackHook(plugin, \"load\", async (fn, context, args) => {\n    const id = args[0];\n    const ssr = args[1]?.ssr;\n    let _result;\n    let error;\n    const start = Date.now();\n    try {\n      _result = await fn.apply(context, args);\n    } catch (err) {\n      error = err;\n    }\n    const end = Date.now();\n    const result = error ? \"[Error]\" : typeof _result === \"string\" ? _result : _result?.code;\n    const sourcemaps = typeof _result === \"string\" ? null : _result?.map;\n    if (result) {\n      ctx.getRecorder(ssr).recordLoad(id, {\n        name: plugin.name,\n        result,\n        start,\n        end,\n        sourcemaps,\n        error: error ? parseError(error) : void 0\n      });\n    }\n    if (error)\n      throw error;\n    return _result;\n  });\n  hijackHook(plugin, \"resolveId\", async (fn, context, args) => {\n    const id = args[0];\n    const ssr = args[2]?.ssr;\n    let _result;\n    let error;\n    const start = Date.now();\n    try {\n      _result = await fn.apply(context, args);\n    } catch (err) {\n      error = err;\n    }\n    const end = Date.now();\n    if (!ctx.filter(id)) {\n      if (error)\n        throw error;\n      return _result;\n    }\n    const result = error ? stringifyError(error) : typeof _result === \"object\" ? _result?.id : _result;\n    if (result && result !== id) {\n      ctx.getRecorder(ssr).recordResolveId(id, {\n        name: plugin.name,\n        result,\n        start,\n        end,\n        error\n      });\n    }\n    if (error)\n      throw error;\n    return _result;\n  });\n}\nfunction parseError(error) {\n  const stack = parse(error);\n  const message = error.message || String(error);\n  return {\n    message,\n    stack,\n    raw: error\n  };\n}\nfunction stringifyError(err) {\n  return String(err.stack ? err.stack : err);\n}\nconst defaults = Object.freeze({\n  ignoreUnknown: false,\n  respectType: false,\n  respectFunctionNames: false,\n  respectFunctionProperties: false,\n  unorderedObjects: true,\n  unorderedArrays: false,\n  unorderedSets: false,\n  excludeKeys: void 0,\n  excludeValues: void 0,\n  replacer: void 0\n});\nfunction objectHash(object, options) {\n  if (options) {\n    options = { ...defaults, ...options };\n  } else {\n    options = defaults;\n  }\n  const hasher = createHasher(options);\n  hasher.dispatch(object);\n  return hasher.toString();\n}\nconst defaultPrototypesKeys = Object.freeze([\n  \"prototype\",\n  \"__proto__\",\n  \"constructor\"\n]);\nfunction createHasher(options) {\n  let buff = \"\";\n  let context = /* @__PURE__ */ new Map();\n  const write = (str) => {\n    buff += str;\n  };\n  return {\n    toString() {\n      return buff;\n    },\n    getContext() {\n      return context;\n    },\n    dispatch(value) {\n      if (options.replacer) {\n        value = options.replacer(value);\n      }\n      const type = value === null ? \"null\" : typeof value;\n      return this[type](value);\n    },\n    object(object) {\n      if (object && typeof object.toJSON === \"function\") {\n        return this.object(object.toJSON());\n      }\n      const objString = Object.prototype.toString.call(object);\n      let objType = \"\";\n      const objectLength = objString.length;\n      if (objectLength < 10) {\n        objType = \"unknown:[\" + objString + \"]\";\n      } else {\n        objType = objString.slice(8, objectLength - 1);\n      }\n      objType = objType.toLowerCase();\n      let objectNumber = null;\n      if ((objectNumber = context.get(object)) === void 0) {\n        context.set(object, context.size);\n      } else {\n        return this.dispatch(\"[CIRCULAR:\" + objectNumber + \"]\");\n      }\n      if (typeof Buffer !== \"undefined\" && Buffer.isBuffer && Buffer.isBuffer(object)) {\n        write(\"buffer:\");\n        return write(object.toString(\"utf8\"));\n      }\n      if (objType !== \"object\" && objType !== \"function\" && objType !== \"asyncfunction\") {\n        if (this[objType]) {\n          this[objType](object);\n        } else if (!options.ignoreUnknown) {\n          this.unkown(object, objType);\n        }\n      } else {\n        let keys = Object.keys(object);\n        if (options.unorderedObjects) {\n          keys = keys.sort();\n        }\n        let extraKeys = [];\n        if (options.respectType !== false && !isNativeFunction(object)) {\n          extraKeys = defaultPrototypesKeys;\n        }\n        if (options.excludeKeys) {\n          keys = keys.filter((key) => {\n            return !options.excludeKeys(key);\n          });\n          extraKeys = extraKeys.filter((key) => {\n            return !options.excludeKeys(key);\n          });\n        }\n        write(\"object:\" + (keys.length + extraKeys.length) + \":\");\n        const dispatchForKey = (key) => {\n          this.dispatch(key);\n          write(\":\");\n          if (!options.excludeValues) {\n            this.dispatch(object[key]);\n          }\n          write(\",\");\n        };\n        for (const key of keys) {\n          dispatchForKey(key);\n        }\n        for (const key of extraKeys) {\n          dispatchForKey(key);\n        }\n      }\n    },\n    array(arr, unordered) {\n      unordered = unordered === void 0 ? options.unorderedArrays !== false : unordered;\n      write(\"array:\" + arr.length + \":\");\n      if (!unordered || arr.length <= 1) {\n        for (const entry of arr) {\n          this.dispatch(entry);\n        }\n        return;\n      }\n      const contextAdditions = /* @__PURE__ */ new Map();\n      const entries = arr.map((entry) => {\n        const hasher = createHasher(options);\n        hasher.dispatch(entry);\n        for (const [key, value] of hasher.getContext()) {\n          contextAdditions.set(key, value);\n        }\n        return hasher.toString();\n      });\n      context = contextAdditions;\n      entries.sort();\n      return this.array(entries, false);\n    },\n    date(date) {\n      return write(\"date:\" + date.toJSON());\n    },\n    symbol(sym) {\n      return write(\"symbol:\" + sym.toString());\n    },\n    unkown(value, type) {\n      write(type);\n      if (!value) {\n        return;\n      }\n      write(\":\");\n      if (value && typeof value.entries === \"function\") {\n        return this.array(\n          Array.from(value.entries()),\n          true\n          /* ordered */\n        );\n      }\n    },\n    error(err) {\n      return write(\"error:\" + err.toString());\n    },\n    boolean(bool) {\n      return write(\"bool:\" + bool);\n    },\n    string(string) {\n      write(\"string:\" + string.length + \":\");\n      write(string);\n    },\n    function(fn) {\n      write(\"fn:\");\n      if (isNativeFunction(fn)) {\n        this.dispatch(\"[native]\");\n      } else {\n        this.dispatch(fn.toString());\n      }\n      if (options.respectFunctionNames !== false) {\n        this.dispatch(\"function-name:\" + String(fn.name));\n      }\n      if (options.respectFunctionProperties) {\n        this.object(fn);\n      }\n    },\n    number(number) {\n      return write(\"number:\" + number);\n    },\n    xml(xml) {\n      return write(\"xml:\" + xml.toString());\n    },\n    null() {\n      return write(\"Null\");\n    },\n    undefined() {\n      return write(\"Undefined\");\n    },\n    regexp(regex) {\n      return write(\"regex:\" + regex.toString());\n    },\n    uint8array(arr) {\n      write(\"uint8array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    uint8clampedarray(arr) {\n      write(\"uint8clampedarray:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    int8array(arr) {\n      write(\"int8array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    uint16array(arr) {\n      write(\"uint16array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    int16array(arr) {\n      write(\"int16array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    uint32array(arr) {\n      write(\"uint32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    int32array(arr) {\n      write(\"int32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    float32array(arr) {\n      write(\"float32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    float64array(arr) {\n      write(\"float64array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    arraybuffer(arr) {\n      write(\"arraybuffer:\");\n      return this.dispatch(new Uint8Array(arr));\n    },\n    url(url) {\n      return write(\"url:\" + url.toString());\n    },\n    map(map) {\n      write(\"map:\");\n      const arr = [...map];\n      return this.array(arr, options.unorderedSets !== false);\n    },\n    set(set) {\n      write(\"set:\");\n      const arr = [...set];\n      return this.array(arr, options.unorderedSets !== false);\n    },\n    file(file) {\n      write(\"file:\");\n      return this.dispatch([file.name, file.size, file.type, file.lastModfied]);\n    },\n    blob() {\n      if (options.ignoreUnknown) {\n        return write(\"[blob]\");\n      }\n      throw new Error(\n        'Hashing Blob objects is currently not supported\\nUse \"options.replacer\" or \"options.ignoreUnknown\"\\n'\n      );\n    },\n    domwindow() {\n      return write(\"domwindow\");\n    },\n    bigint(number) {\n      return write(\"bigint:\" + number.toString());\n    },\n    /* Node.js standard native objects */\n    process() {\n      return write(\"process\");\n    },\n    timer() {\n      return write(\"timer\");\n    },\n    pipe() {\n      return write(\"pipe\");\n    },\n    tcp() {\n      return write(\"tcp\");\n    },\n    udp() {\n      return write(\"udp\");\n    },\n    tty() {\n      return write(\"tty\");\n    },\n    statwatcher() {\n      return write(\"statwatcher\");\n    },\n    securecontext() {\n      return write(\"securecontext\");\n    },\n    connection() {\n      return write(\"connection\");\n    },\n    zlib() {\n      return write(\"zlib\");\n    },\n    context() {\n      return write(\"context\");\n    },\n    nodescript() {\n      return write(\"nodescript\");\n    },\n    httpparser() {\n      return write(\"httpparser\");\n    },\n    dataview() {\n      return write(\"dataview\");\n    },\n    signal() {\n      return write(\"signal\");\n    },\n    fsevent() {\n      return write(\"fsevent\");\n    },\n    tlswrap() {\n      return write(\"tlswrap\");\n    }\n  };\n}\nconst nativeFunc = \"[native code] }\";\nconst nativeFuncLength = nativeFunc.length;\nfunction isNativeFunction(f) {\n  if (typeof f !== \"function\") {\n    return false;\n  }\n  return Function.prototype.toString.call(f).slice(-nativeFuncLength) === nativeFunc;\n}\nclass WordArray {\n  constructor(words, sigBytes) {\n    words = this.words = words || [];\n    this.sigBytes = sigBytes === void 0 ? words.length * 4 : sigBytes;\n  }\n  toString(encoder) {\n    return (encoder || Hex).stringify(this);\n  }\n  concat(wordArray) {\n    this.clamp();\n    if (this.sigBytes % 4) {\n      for (let i = 0; i < wordArray.sigBytes; i++) {\n        const thatByte = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n        this.words[this.sigBytes + i >>> 2] |= thatByte << 24 - (this.sigBytes + i) % 4 * 8;\n      }\n    } else {\n      for (let j = 0; j < wordArray.sigBytes; j += 4) {\n        this.words[this.sigBytes + j >>> 2] = wordArray.words[j >>> 2];\n      }\n    }\n    this.sigBytes += wordArray.sigBytes;\n    return this;\n  }\n  clamp() {\n    this.words[this.sigBytes >>> 2] &= 4294967295 << 32 - this.sigBytes % 4 * 8;\n    this.words.length = Math.ceil(this.sigBytes / 4);\n  }\n  clone() {\n    return new WordArray([...this.words]);\n  }\n}\nconst Hex = {\n  stringify(wordArray) {\n    const hexChars = [];\n    for (let i = 0; i < wordArray.sigBytes; i++) {\n      const bite = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n      hexChars.push((bite >>> 4).toString(16), (bite & 15).toString(16));\n    }\n    return hexChars.join(\"\");\n  }\n};\nconst Base64 = {\n  stringify(wordArray) {\n    const keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    const base64Chars = [];\n    for (let i = 0; i < wordArray.sigBytes; i += 3) {\n      const byte1 = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n      const byte2 = wordArray.words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;\n      const byte3 = wordArray.words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;\n      const triplet = byte1 << 16 | byte2 << 8 | byte3;\n      for (let j = 0; j < 4 && i * 8 + j * 6 < wordArray.sigBytes * 8; j++) {\n        base64Chars.push(keyStr.charAt(triplet >>> 6 * (3 - j) & 63));\n      }\n    }\n    return base64Chars.join(\"\");\n  }\n};\nconst Latin1 = {\n  parse(latin1Str) {\n    const latin1StrLength = latin1Str.length;\n    const words = [];\n    for (let i = 0; i < latin1StrLength; i++) {\n      words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;\n    }\n    return new WordArray(words, latin1StrLength);\n  }\n};\nconst Utf8 = {\n  parse(utf8Str) {\n    return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n  }\n};\nclass BufferedBlockAlgorithm {\n  constructor() {\n    this._data = new WordArray();\n    this._nDataBytes = 0;\n    this._minBufferSize = 0;\n    this.blockSize = 512 / 32;\n  }\n  reset() {\n    this._data = new WordArray();\n    this._nDataBytes = 0;\n  }\n  _append(data) {\n    if (typeof data === \"string\") {\n      data = Utf8.parse(data);\n    }\n    this._data.concat(data);\n    this._nDataBytes += data.sigBytes;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _doProcessBlock(_dataWords, _offset) {\n  }\n  _process(doFlush) {\n    let processedWords;\n    let nBlocksReady = this._data.sigBytes / (this.blockSize * 4);\n    if (doFlush) {\n      nBlocksReady = Math.ceil(nBlocksReady);\n    } else {\n      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n    }\n    const nWordsReady = nBlocksReady * this.blockSize;\n    const nBytesReady = Math.min(nWordsReady * 4, this._data.sigBytes);\n    if (nWordsReady) {\n      for (let offset = 0; offset < nWordsReady; offset += this.blockSize) {\n        this._doProcessBlock(this._data.words, offset);\n      }\n      processedWords = this._data.words.splice(0, nWordsReady);\n      this._data.sigBytes -= nBytesReady;\n    }\n    return new WordArray(processedWords, nBytesReady);\n  }\n}\nclass Hasher extends BufferedBlockAlgorithm {\n  update(messageUpdate) {\n    this._append(messageUpdate);\n    this._process();\n    return this;\n  }\n  finalize(messageUpdate) {\n    if (messageUpdate) {\n      this._append(messageUpdate);\n    }\n  }\n}\nconst H = [\n  1779033703,\n  -1150833019,\n  1013904242,\n  -1521486534,\n  1359893119,\n  -1694144372,\n  528734635,\n  1541459225\n];\nconst K = [\n  1116352408,\n  1899447441,\n  -1245643825,\n  -373957723,\n  961987163,\n  1508970993,\n  -1841331548,\n  -1424204075,\n  -670586216,\n  310598401,\n  607225278,\n  1426881987,\n  1925078388,\n  -2132889090,\n  -1680079193,\n  -1046744716,\n  -459576895,\n  -272742522,\n  264347078,\n  604807628,\n  770255983,\n  1249150122,\n  1555081692,\n  1996064986,\n  -1740746414,\n  -1473132947,\n  -1341970488,\n  -1084653625,\n  -958395405,\n  -710438585,\n  113926993,\n  338241895,\n  666307205,\n  773529912,\n  1294757372,\n  1396182291,\n  1695183700,\n  1986661051,\n  -2117940946,\n  -1838011259,\n  -1564481375,\n  -1474664885,\n  -1035236496,\n  -949202525,\n  -778901479,\n  -694614492,\n  -200395387,\n  275423344,\n  430227734,\n  506948616,\n  659060556,\n  883997877,\n  958139571,\n  1322822218,\n  1537002063,\n  1747873779,\n  1955562222,\n  2024104815,\n  -2067236844,\n  -1933114872,\n  -1866530822,\n  -1538233109,\n  -1090935817,\n  -965641998\n];\nconst W = [];\nclass SHA256 extends Hasher {\n  constructor() {\n    super(...arguments);\n    this._hash = new WordArray([...H]);\n  }\n  reset() {\n    super.reset();\n    this._hash = new WordArray([...H]);\n  }\n  _doProcessBlock(M, offset) {\n    const H2 = this._hash.words;\n    let a = H2[0];\n    let b = H2[1];\n    let c2 = H2[2];\n    let d = H2[3];\n    let e = H2[4];\n    let f = H2[5];\n    let g = H2[6];\n    let h = H2[7];\n    for (let i = 0; i < 64; i++) {\n      if (i < 16) {\n        W[i] = M[offset + i] | 0;\n      } else {\n        const gamma0x = W[i - 15];\n        const gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;\n        const gamma1x = W[i - 2];\n        const gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;\n        W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n      }\n      const ch = e & f ^ ~e & g;\n      const maj = a & b ^ a & c2 ^ b & c2;\n      const sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);\n      const sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);\n      const t1 = h + sigma1 + ch + K[i] + W[i];\n      const t2 = sigma0 + maj;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t1 | 0;\n      d = c2;\n      c2 = b;\n      b = a;\n      a = t1 + t2 | 0;\n    }\n    H2[0] = H2[0] + a | 0;\n    H2[1] = H2[1] + b | 0;\n    H2[2] = H2[2] + c2 | 0;\n    H2[3] = H2[3] + d | 0;\n    H2[4] = H2[4] + e | 0;\n    H2[5] = H2[5] + f | 0;\n    H2[6] = H2[6] + g | 0;\n    H2[7] = H2[7] + h | 0;\n  }\n  finalize(messageUpdate) {\n    super.finalize(messageUpdate);\n    const nBitsTotal = this._nDataBytes * 8;\n    const nBitsLeft = this._data.sigBytes * 8;\n    this._data.words[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;\n    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(\n      nBitsTotal / 4294967296\n    );\n    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;\n    this._data.sigBytes = this._data.words.length * 4;\n    this._process();\n    return this._hash;\n  }\n}\nfunction sha256base64(message) {\n  return new SHA256().finalize(message).toString(Base64);\n}\nfunction hash(object, options = {}) {\n  const hashed = typeof object === \"string\" ? object : objectHash(object, options);\n  return sha256base64(hashed).slice(0, 10);\n}\nasync function generateBuild(ctx, config) {\n  const {\n    outputDir = \".vite-inspect\"\n  } = ctx.options;\n  const targetDir = isAbsolute(outputDir) ? outputDir : resolve(config.root, outputDir);\n  const reportsDir = join(targetDir, \"reports\");\n  await fs.emptyDir(targetDir);\n  await fs.ensureDir(reportsDir);\n  await fs.copy(DIR_CLIENT, targetDir);\n  const isVirtual = (pluginName, transformName) => pluginName !== DUMMY_LOAD_PLUGIN_NAME && transformName !== \"vite:load-fallback\";\n  function list() {\n    return {\n      root: config.root,\n      modules: ctx.getModulesInfo(ctx.recorderClient, null, isVirtual),\n      ssrModules: ctx.getModulesInfo(ctx.recorderServer, null, isVirtual)\n    };\n  }\n  async function dumpModuleInfo(dir, recorder, ssr = false) {\n    await fs.ensureDir(dir);\n    return Promise.all(\n      Object.entries(recorder.transform).map(\n        ([id, info]) => fs.writeJSON(\n          join(dir, `${hash(id)}.json`),\n          {\n            resolvedId: ctx.resolveId(id, ssr),\n            transforms: info\n          },\n          { spaces: 2 }\n        )\n      )\n    );\n  }\n  await Promise.all([\n    fs.writeFile(\n      join(targetDir, \"index.html\"),\n      (await fs.readFile(join(targetDir, \"index.html\"), \"utf-8\")).replace(\n        'data-vite-inspect-mode=\"DEV\"',\n        'data-vite-inspect-mode=\"BUILD\"'\n      )\n    ),\n    fs.writeJSON(\n      join(reportsDir, \"list.json\"),\n      list(),\n      { spaces: 2 }\n    ),\n    fs.writeJSON(\n      join(reportsDir, \"metrics.json\"),\n      ctx.getPluginMetrics(false),\n      { spaces: 2 }\n    ),\n    fs.writeJSON(\n      join(reportsDir, \"metrics-ssr.json\"),\n      ctx.getPluginMetrics(true),\n      { spaces: 2 }\n    ),\n    dumpModuleInfo(join(reportsDir, \"transform\"), ctx.recorderClient),\n    dumpModuleInfo(join(reportsDir, \"transform-ssr\"), ctx.recorderServer, true)\n  ]);\n  return targetDir;\n}\nasync function openBrowser(address) {\n  await __vitePreload(() => import(\"open\"),__VITE_IS_MODERN__?\"__VITE_PRELOAD__\":void 0).then((r) => r.default(address, { newInstance: true })).catch(() => {\n  });\n}\nfunction createPreviewServer(staticPath) {\n  const server = createServer();\n  const statics = sirv(staticPath);\n  server.on(\"request\", (req, res) => {\n    statics(req, res, () => {\n      res.statusCode = 404;\n      res.end(\"File not found\");\n    });\n  });\n  server.listen(0, () => {\n    const { port } = server.address();\n    const url = `http://localhost:${port}`;\n    console.log(`  ${c.green(\"\")}  ${c.bold(\"Inspect Preview Started\")}: ${url}`);\n    openBrowser(url);\n  });\n}\nconst NAME = \"vite-plugin-inspect\";\nconst isCI = !!process.env.CI;\nfunction PluginInspect(options = {}) {\n  const {\n    dev = true,\n    build = false,\n    silent = false,\n    open: _open = false\n  } = options;\n  if (!dev && !build) {\n    return {\n      name: NAME\n    };\n  }\n  const ctx = new ViteInspectContext(options);\n  const timestampRE = /\\bt=\\d{13}&?\\b/;\n  const trailingSeparatorRE = /[?&]$/;\n  let config;\n  const serverPerf = {\n    middleware: {}\n  };\n  function setupMiddlewarePerf(middlewares) {\n    let firstMiddlewareIndex = -1;\n    middlewares.forEach((middleware, index) => {\n      const { handle: originalHandle } = middleware;\n      if (typeof originalHandle !== \"function\" || !originalHandle.name)\n        return middleware;\n      middleware.handle = (...middlewareArgs) => {\n        var _a;\n        let req;\n        if (middlewareArgs.length === 4)\n          [, req] = middlewareArgs;\n        else\n          [req] = middlewareArgs;\n        const start = Date.now();\n        const url = req.url?.replace(timestampRE, \"\").replace(trailingSeparatorRE, \"\");\n        (_a = serverPerf.middleware)[url] ?? (_a[url] = []);\n        if (firstMiddlewareIndex < 0)\n          firstMiddlewareIndex = index;\n        if (index === firstMiddlewareIndex)\n          serverPerf.middleware[url] = [];\n        const result = originalHandle(...middlewareArgs);\n        Promise.resolve(result).then(() => {\n          const total = Date.now() - start;\n          const metrics = serverPerf.middleware[url];\n          serverPerf.middleware[url].push({\n            self: metrics.length ? Math.max(total - metrics[metrics.length - 1].total, 0) : total,\n            total,\n            name: originalHandle.name\n          });\n        });\n        return result;\n      };\n      Object.defineProperty(middleware.handle, \"name\", {\n        value: originalHandle.name,\n        configurable: true,\n        enumerable: true\n      });\n      return middleware;\n    });\n  }\n  function configureServer(server) {\n    const _invalidateModule = server.moduleGraph.invalidateModule;\n    server.moduleGraph.invalidateModule = function(...args) {\n      const mod = args[0];\n      if (mod?.id) {\n        ctx.recorderClient.invalidate(mod.id);\n        ctx.recorderServer.invalidate(mod.id);\n      }\n      return _invalidateModule.apply(this, args);\n    };\n    const base = (options.base ?? server.config.base) || \"/\";\n    server.middlewares.use(`${base}__inspect`, sirv(DIR_CLIENT, {\n      single: true,\n      dev: true\n    }));\n    const rpcFunctions = {\n      list: () => ctx.getList(server),\n      getIdInfo,\n      getPluginMetrics: (ssr = false) => ctx.getPluginMetrics(ssr),\n      getServerMetrics,\n      resolveId: (id, ssr = false) => ctx.resolveId(id, ssr),\n      clear: clearId,\n      moduleUpdated: () => {\n      }\n    };\n    const rpcServer = createRPCServer(\"vite-plugin-inspect\", server.ws, rpcFunctions);\n    const debouncedModuleUpdated = debounce(() => {\n      rpcServer.moduleUpdated.asEvent();\n    }, 100);\n    server.middlewares.use((req, res, next) => {\n      debouncedModuleUpdated();\n      next();\n    });\n    function getServerMetrics() {\n      return serverPerf || {};\n    }\n    async function getIdInfo(id, ssr = false, clear = false) {\n      if (clear) {\n        clearId(id, ssr);\n        try {\n          await server.transformRequest(id, { ssr });\n        } catch {\n        }\n      }\n      const resolvedId = ctx.resolveId(id, ssr);\n      const recorder = ctx.getRecorder(ssr);\n      return {\n        resolvedId,\n        transforms: recorder.transform[resolvedId] || []\n      };\n    }\n    function clearId(_id, ssr = false) {\n      const id = ctx.resolveId(_id);\n      if (id) {\n        const mod = server.moduleGraph.getModuleById(id);\n        if (mod)\n          server.moduleGraph.invalidateModule(mod);\n        ctx.getRecorder(ssr).invalidate(id);\n      }\n    }\n    const _print = server.printUrls;\n    server.printUrls = () => {\n      let host = `${config.server.https ? \"https\" : \"http\"}://localhost:${config.server.port || \"80\"}`;\n      const url = server.resolvedUrls?.local[0];\n      if (url) {\n        try {\n          const u = new URL(url);\n          host = `${u.protocol}//${u.host}`;\n        } catch (error) {\n          console.warn(\"Parse resolved url failed:\", error);\n        }\n      }\n      _print();\n      if (!silent) {\n        const colorUrl = (url2) => c.green(url2.replace(/:(\\d+)\\//, (_, port) => `:${c.bold(port)}/`));\n        console.log(`  ${c.green(\"\")}  ${c.bold(\"Inspect\")}: ${colorUrl(`${host}${base}__inspect/`)}`);\n      }\n      if (_open && !isCI) {\n        setTimeout(() => {\n          openBrowser(`${host}${base}__inspect/`);\n        }, 500);\n      }\n    };\n    return rpcFunctions;\n  }\n  const plugin = {\n    name: NAME,\n    enforce: \"pre\",\n    apply(_, { command }) {\n      if (command === \"serve\" && dev)\n        return true;\n      if (command === \"build\" && build)\n        return true;\n      return false;\n    },\n    configResolved(_config) {\n      config = ctx.config = _config;\n      config.plugins.forEach((plugin2) => hijackPlugin(plugin2, ctx));\n      const _createResolver = config.createResolver;\n      config.createResolver = function(...args) {\n        const _resolver = _createResolver.apply(this, args);\n        return async function(...args2) {\n          const id = args2[0];\n          const aliasOnly = args2[2];\n          const ssr = args2[3];\n          const start = Date.now();\n          const result = await _resolver.apply(this, args2);\n          const end = Date.now();\n          if (result && result !== id) {\n            const pluginName = aliasOnly ? \"alias\" : \"vite:resolve (+alias)\";\n            ctx.getRecorder(ssr).recordResolveId(id, { name: pluginName, result, start, end });\n          }\n          return result;\n        };\n      };\n    },\n    configureServer(server) {\n      const rpc = configureServer(server);\n      plugin.api = {\n        rpc\n      };\n      return () => {\n        setupMiddlewarePerf(server.middlewares.stack);\n      };\n    },\n    load: {\n      order: \"pre\",\n      handler(id, { ssr } = {}) {\n        ctx.getRecorder(ssr).invalidate(id);\n        return null;\n      }\n    },\n    handleHotUpdate({ modules, server }) {\n      const ids = modules.map((module) => module.id);\n      server.ws.send({\n        type: \"custom\",\n        event: \"vite-plugin-inspect:update\",\n        data: { ids }\n      });\n    },\n    async buildEnd() {\n      if (!build)\n        return;\n      const dir = await generateBuild(ctx, config);\n      console.log(c.green(\"Inspect report generated at\"), c.dim(`${dir}`));\n      if (_open && !isCI)\n        createPreviewServer(dir);\n    }\n  };\n  return plugin;\n}\nPluginInspect.getViteInspectAPI = function(plugins) {\n  return plugins.find((p) => p.name === NAME)?.api;\n};\nexport { PluginInspect as default };\n",
      "start": 1718972211415,
      "end": 1718972211417,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "vite:reporter",
      "start": 1718972211417,
      "end": 1718972211417,
      "order": "normal"
    }
  ]
}
